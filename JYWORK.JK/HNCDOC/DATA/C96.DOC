  1. 개요
    8096 C Langulage를 사용하기 위하여는  C 언어이외에 최소한 하나의 언어는 더 
사용하여야한다. 그 이유는 C 루틴 자체가  스스로 시작할 수 없기 때문인데, Intel
의 C Complier체계에서는  PLM의 사용을 권장하고 있는듯하다. 그  이유는 C 언어는 
대게  main() 함수로  시작을  하는데 이유는  아직  모르겠지만 ASM96에서  main을 
External 로 선언하면  Error를 발생하고 Assemble이 되지를  않는다. (실험을 한번 
해 보시길).  그런데 예제 ( CSTART.P96 & CSTART.OBJ )의 PLM 프로그램은 main함수
를 External로 선언하고도 에러없이 수행이 되고있다.  대부분의 독자는 PLM을 아직 
사용해 보지 않았으리라 생각하고 본고에서는 ASM 과 C 만을 고려대상으로 삼는다.

  96의 C 언어를 공부하기 위하여는  실험용 보드가 필수적으로 있어야 한다고 생각
되는데 본고에서는  Address $2000~$3fff에 ROM이  연결되어있고, $8000~$ffff 에는 
RAM이 연결되어 있는 것으로 가정하고 있다.   참조용으로 본인이 사용하고 있는 시
험용 보드의 회로도( T96.SCH &  T96.LIB )를 첨부하였으며 아마 ORCAD V3.1 일테니 
버젼이 맞지 않는분은 FIX31.EXE (?) 을  사용하여 버젼을 맞추어야 할 것이다.  그
리고 이정도는 만능 기판에 작업 가능할 것으로 보나, 혹시 기판이 꼭, 절실히 요구
되는 사람은  아주 비싼 값에 판매할테니 연락할것.
  연락처 : 한국 테크노 벤쳐 연구소 자동제어 연구실 최 문승주임. 575-8660~2

   ROM에는 예제중의 MON96.SRC (8096용) 또는 MON196.SRC (80196용) 모니터 프로그
램이 ASSEMBLE & Linking 되어 구워져 있는 것으로 가정한다. 위의 모니터 프로그램
은 Intel HEX Format의 File을 Down-Load 받을수 있는 기능과 특정 번지에서 프로그
램을 실행 시킬수  있는 기능만을 포함한 단순한 것이므로  추가 기능은 독자분들이 
보태기 바란다.  그리고 2개의 프로그램은  모두 12MHZ Clock 이 연결되어있는 상태
에서 19600 bps, 8 bit, No Parity, 1 Stop bit로 동작하므로 클럭의 주파수가 다르
면 프로그램의 수정이 요망된다.  다운로드 기능은 커서 상태에서 Intel Hex Format
의 화일을 그냥 보내면 ( 이야기의 편지보내기나 프로콤의 ASCII 전송으로 ) 알아서 
램의 번지로 들어간다.  만약 모니터  프로그램을 사용치 않고 바로 롬으로 굽고 싶
을 경우는 ASM 프로그램과 RL96 에서 롬에 관계된 8000번지를 모두 2000번지로 바꾸
면 된다.
  본인이 가지고 있는 C Complier는 V1.0  87년판과 V1.1 88년 판이 있는데 둘다 약
간의 문제점을 가지고 있다.  V1.0  버젼은 사용하는 에디터에 따라서 마지막에 End 
of File 코드를 에러로 인식하여 컴파일시 Warning 을 발생하며 ASM list (후술하는 
CODE Option) 를 생성하지 않는다.  현제까지 본인이 시험해 본 에디터 중에는 인털
의 AEDIT 와 Norton Commander  NC.EXE 중에 내장된 에디터만이 이러한 문제가 발생
되지 않고 여타의 에디터 ( SK.COM, BC.EXE, .... )에서는 Warning이 발생 되었다 ( 
C 소스를 Disasm한 리스트가 필요 없다면 무시하여도 무방함)
  V1.1의 문제는 컴파일러 버그인데 예로서  아래와 같은 프로그램이 실행되지 않는
다.

        for ( i=0; i<100; i++)
        {
           x[i]=y[i]=100;
        }

  이유를 찾느라 한참 걸렸는데, 컴파일된 어셈 리스트를 본 결과 스텍의 Push, Pop 
에서 버그가  있었다.  그리고  전체적인 컴파일 결과를 어셈으로  보니 V1.1보다는 
V1.0 이 효율이 좋은것 같았다. (버전이 낮은게 좋은 경우는 처음인데...)
  그리고 귀찮게 다음부터의  내용을 읽고싶지 않은 분은 아래와  같은 베치 파일을 
이용하면 손쉬울 것이다.
  1) AC.BAT  : ASM 과 C 화일을 같이 컴파일하고 링크하여 Intel HEX 화일 생성
  =================================
  asm96 %1.asm
  c96 %2.c co
  rl96       %2.obj,%1.obj,c96.lib,fpal96.lib,plm96.lib       ro(8000h-0afffh) 
ra(0b000h-0ffffh)
  oh %2
  =================================
  사용예 : ASM File : START.ASM,   C File : C_TEST.C 일경우.
  C:\96>ac start c_test

  2) C.BAT : ASM이 컴파일 되어 START.OBJ가 현 디렉터리에 있고  C만을 컴파일.
  ==================================
  c96 %1.c co
  rl96      %1.obj,start.obj,c96.lib,fpal96.lib,plm96.lib     ro(8000h-0afffh) 
ra(0b000h-0ffffh)
  oh %1
  ===================================
  사용예
  C:\96>c c_test

  2. ASSEMBLER

  예제 프로그램 : start.asm
  ============================================
  $include (8096.inc)
                  public  getchar
                  public  putchar
                  public  stack_p

                  RSEG          ; 링크시 RAM 영역으로 어드레스가 할당됨.
  serial_stat:    DSB    1

                 CSEG   AT   8000H    ; 링크시 ROM 영역으로 어드레스가 할당됨
                 DCW    INT_TIMER     ; ROM을 구울경우는 8000을 2000으로 바꿈
                 DCW    INT_AD        ; Interrupt Vector
                 DCW    INT_HSI
                 DCW    INT_HSO
                 DCW    INT_HSI0
                 DCW    INT_S_TIMER
                 DCW    INT_SERIAL
                 DCW    INT_EXT
                 DCW    INT_SOFT
                 DCW    0
                 DCW    0
                 DCW    0
                 DCB    0CDH            ; CCR

                 CSEG    AT   8080H   ; ROM을 구울경우는 8080을 2080으로 바꿈
  ;
  ; POWER ON START
  ;
  START:
                 extrn   _main          ; c 의 시작루틴.  main 으로하면 에러??
                 ldb     serial_stat,#0ffh  ; 모니터 프로그램이 있는것으로
                                     ;  가정하여 시리얼의 초기화 루틴이 없음.
                 LCALL   _main       ; C Routine Call.
                 ret
  INT_HSI:                              ; 인터럽트를 사용할 경우는 루틴 삽입
                 ret
  INT_HSO:
                 ret
  INT_HSI0:
                 ret
  INT_SERIAL:
                 ret
  INT_EXT:
                 ret
  INT_SOFT:
                 ret
  INT_TIMER:
                 ret
  INT_AD:
                 ret
  INT_S_TIMER:
                 ret

  char           equ    01ch
  getchar:                                      ; C 에서 사용되는 getchar()
                 orb     serial_stat,sp_stat
                 jbc     serial_stat,6,getchar
                 ldbze   char,sbuf
                 ldb     sbuf,char
                 andb    serial_stat,#0bfh
                 ret
  putchar:                                      ; C 에서 사용되는 putchar()
                 orb     serial_stat,sp_stat
                 jbc     serial_stat,5,putchar
                 ld      char,2h[sp]
                 ldb     sbuf,char
                 andb    serial_stat,#0dfh
                 ret
  stack_p:                                ; Test Routine.
                                          ; 현재의 Stack Pointer 값을 리턴
                 ld      char,sp
                 ret

                 END
  =============================================================
  위 에제에 대충의  중요한 사항은 다 언급이 되어 있는데,  주의할 사항은 다음과 
같다.
  1) ROM 영역에 갈 내용 : CSEG 로 시작.
  2) RAM 영역에 갈 내용 : RSEG 로 시작.
  3) C 언어에서의 변수전달.  [  int putchar(int c)  ]
        Stack에 저장되어 있음.
  4) ASM 에서 C 로 결과값의 리턴 [ int getchar()  ]
        절대번지 $1C 를 이용.

  3. C Complier

  예제 프로그램 : C_TEST.C
  =======================================
  #include <stdio.h>
  extern int stack_p();  /* ASM Routine */
  _main()                /* ASM에서 _main 으로 호출 */
  {
     printf(" Start!!!!!! \n\r");
     printf(" Stack Pointer = %d \n\r",stack_p());
  }
  ========================================
  ****  Complier Controls Command
  단축  DEFAULT CONTROL
  CO    NOCO    [NO]CODE        C 를 어셈으로 변환한 리스트 출력
  CD    NOCD    [NO]COND        #if 가 있을경우 리스트에서 삭제
  DB    NODB    [NO]DEBUG
  DF            DEFINE("name"[="token"],....)
  IC            INCLUDE(PATHNAME[,...])
  LI    NOLI    [NO]LIST
  LC    NOLC    [NO]LISTINCLUDE
                MOD196
  OJ    OJ      [NO]OBJECT[ (phtaname) ]
  OT    OT(1)   OPTIMIZE(0|1|2|3)
  PL    PL(60)  PAGELENGTH(length)
  PW    PW(120) PAGEWIDTH(width)
  PP    NOPP    [NO]PREPRINT
  PR    PR      [NO]PRINT[pathname]
  RE    RE      [NON]REENTRANT
  RG    RG(ALL) REGISTERS(num|ALL)
  SI    SI      [NO]SEARCHINCLUDE
  SB    NOSB    [NO]SYMBOLS
  TT    TT      TITLE(string)
  TY    TY      [NO]TYPE
  XR    NOXR    [NO]REF
  ==================================================
  주의 :  math.h도 없고 삼각함수등의 수학연산용  라이브러리도없음.  필요시에는 
만들어야함.  ( 8051 C 보담두 못하게스리 )

  4. Linker
  ========================================
  ****  Linker  Controls Command
  단축  DEFAULT         CONTROL
  PR    PR(file.M96)    [NO]PRINT
  LI    LI(all)         [NO]LIST
  IX    NOIX            [NO]IXREF
  PW    PW(120)         PAGEWIDTH
  NA    NA(mod name)    NAME
  PU    NOPU            [NO]PURGE
  TC    TC              [NO]TYPECHECK
  RA    RA(1AH-1FFFH(STACK))            RAM
  RO    RO(2000H-200FH,2080H-0FFFFH)    ROM
  SS    STACKSIZE       SS(total)
  AS    AS              [NO]ABSSTACK
  OV    NOOV            [NO]REGOVERLAY

  **** 주의 : LINKING 결과를 oh.exe  로 변환 하여야  Intel Hex Format의 화일을 
얻을 수 있음.

   아~~~ 졸려서 더 못쓰겠다....  이정도면 대충 알아서 하겠지...


#137   임상희   (zc5u3p  )
iar 8096 C complier 사용예제                 06/13 14:24   258 line

IAR사의 C Complier중 51은 V4를 넘어 V5가 시판되고 있으나, 96은 아직 V3
이다. 51의 경우 버젼 3과 4는 매우 큰 차이를 보이고 있는데, 가장 큰 차
이는 인터럽트 함수의 추가이다.  컨트롤러의 프로그램을 짜다보면 인터럽
트의 사용이 필요한데 버젼 4부터 인터럽트 함수가 추가되어 굳이 어셈블러
로 인터럽트 벡터지정을 하지 않아도 컴파일러와 링커가 자동으로 조정하여
준다.  그리고 컴파일러의 효율도 상당히 좋아서 Tiny Model의 경우 어셈으
로 짠 프로그램에 비해 실행속도면에서 그리 떨어지지않는다.  때문에 현재
우리 연구소에서는 51로 제어기를 만드는 경우 어셈을 전혀 사용치 않고 C
만으로 프로그램 하고 있다.
  그러나 96의 경우 아직 버젼 3인 관계로 인터럽트 함수가 없어 어셈을 사
용하여야만한다.  어셈이 꼭 필요한 부분은 2000H부터 시작되는 인터럽트 
벡터에 인터럽트 시작부분의 어드레스를 넣는 과정과, 실제 인터럽트 루틴
으로 나눌 수 있다.  그런데 2000번지루틴은 CSTARTUP이라는 이름으로 라이
브러리에 포함되어 있다.  따라서 인터럽트 벡더와 인터럽트 루틴을 같이 
CSTARTUP에 포함하게 되면 인터럽트 루틴이 바뀔때마다 라이브러리를 바꾸
어야 하는 불편이 따르게 된다.  그래서 나는 CSTARTUP루틴에는 꼭 필요한 
최소한의 기능만을 넣어서 라이브러리에 넣고, 여러 프로그램에서 같이 사
용할 수 있도록 구성하였다. 

mycstart.asm
===========================================

    NAME    CSTARTUP
    PUBLIC  startup
    PUBLIC  RESETRUN
    EXTERN  ?C_EXIT
    EXTERN  INT_T_OVER_S
    EXTERN  INT_A2D_S
    EXTERN  INT_HSI_S
    EXTERN  INT_HSO_S
    EXTERN  INT_HSI0_S
    EXTERN  INT_SOFT_T_S
    EXTERN  INT_COM_S
    EXTERN  INT_EXTERN_S
    EXTERN  CHIP_CONFIG
    EXTERN  ASM_START

    RSEG    CSTART
startup:                <<==  여기가 2000H번지.
    DCW INT_T_OVER_S    <<==  실제 값은 Link시 결정됨.
    DCW INT_A2D_S
    DCW INT_HSI_S
    DCW INT_HSO_S
    DCW INT_HSI0_S
    DCW INT_SOFT_T_S
    DCW INT_COM_S
    DCW INT_EXTERN_S

    ORG     startup+18H
    DCB CHIP_CONFIG

    ORG startup+80H
RESETRUN:
    LJMP    ASM_START
    ENDMOD  startup

   MODULE  exit
    PUBLIC  exit
    PUBLIC  ?C_EXIT
    EXTERN  RESETRUN

    RSEG    CODE

?C_EXIT:
    LJMP    RESETRUN
exit    EQU ?C_EXIT
    END
=============================================================
이제 이 루틴을 다음과 같이하여 라이브러리에 있는 루틴과 바꾸어야 한다.
*** 라이브러리 루틴을 변경하여야 하므로 8096 C Library가 있는곳에서 
        작업하여야 한다.
    
C:\8096>a8096 mycstart.asm mycstart mycstart
C:\8096>xlib
* def-cpu 8096
* rep-mod mycstart cl8096
* exit
============================================================
이제 사용자가 필요한 루틴을 작성한다.
수행을 위하여는 최소한 하나의 어셈과 C 화일을 필요로 한다.
어셈화일에는 CSTARTUP에서 EXTERN으로 선언한 이름이 반드시 PUBLIC으로 
선언되어 있어야 후에 링크가 된다.

test_asm.asm
===========================================
    NAME    INITIAL_AND_POWER
; 여기서는 모든 프로그램에 꼭 있어야 할 부분임...
$reg8096.INC
    PUBLIC  CHIP_CONFIG
    PUBLIC  ASM_START
    PUBLICINT_T_OVER_S
    PUBLIC  INT_A2D_S
    PUBLIC  INT_HSI_S
    PUBLIC  INT_HSO_S
    PUBLIC  INT_HSI0_S
    PUBLIC  INT_SOFT_T_S
    PUBLIC  INT_COM_S
    PUBLIC  INT_EXTERN_S

    EXTERN  main
    EXTERN  ?C_EXIT

CHIP_CONFIG EQU   0FDH ;11111101B <<= 요값은 하드웨어에 맞게 조정할것

    RSEG    CODE   ; 
INT_T_OVER_S:   ;TIMER OVER FLOW INTERRUPT SERVICE (INT_T_OVER_S)
INT_A2D_S:      ;A/D CONVERT COMPLITE INTERRUPT SERVICE (INT_A2D_S)
INT_HSI_S:      ;HSI DATA AVAILABLE INTERRUPT SERVICE (INT_HSI_S)
INT_HSO_S:      ;HSO EVENT INTERRUPT SERVICE (INT_HSO_S)
INT_HSI0_S:     ;HSI BIT 0 INTERRUPT SERVICE (INT_HSI0_S)
INT_EXTERN_S:   ;EXTERNAL INTERRPUT SERVICE (INT_EXTERN_S)
        RET
            ; 여기까지 인터럽트루틴은 안쓰는 경우.
            ; 아래것은 어셈루틴으로 쓰는 경우.
INT_SOFT_T_S:
    PUSHF
            ; 여기다 필요한 루틴을 집어넣음.
    POPF
    RET
            ; ** C로 인터럽트 루틴을 짤 경우...
INT_COM_S:      ;SERIAL I/O INTERRUPT SERVICE (INT_CON_S)
    PUSHF
    PUSH    R0
    PUSH    R2
    PUSH    R4
    PUSH    R6
    PUSH    R8
    EXTERN  C_INT_ROUTINE
    LCALL   C_INT_ROUTINE
    POP     R8
    POP     R6
    POP     R4
    POP     R2
    POP     R0
    POPF
    RET
            ; 여기서부터 RESET시 시작하는 부분.
ASM_START:
    LD      SP,#100H  ; <<== 값은 필요에 따라 변경하여야 함.
                      ; 가능한한 RAM의 가장 뒤번지인것이 바람직함.
                      
    EXTERN  ?SEG_INIT_L00   ; C 변수 초기화 라이브러리의 호출.
    LCALL   ?SEG_INIT_L00   ; 초기화가 필요 없을땐 호출 안해도 됨.

    LCALL   main            ; C의 메인루틴 호출
    LJMP    ASM_START       ; 이경우는 C루틴이 끝나면 다시 처음부터 수
                            ; 행함.  필요에 따라 변경할것.
    END
=====================================================================
TEST.C96
====================================================================
#include <io8096.h>
#include <math.h>

/*  내부램의 절대번지를 C에서 변수로 쓸때는 다음과 같이 지정함 
    ** 내부램의 23H번지까지는 C Complier가 사용하므로 유저사용 불가.
*/
#define BASE_REG 0x24
#define reg_x  (*(unsigned int  *) (BASE_REG))   
#define reg_y  (*(unsigned int  *) (BASE_REG+2))

int x,y,z;
double d1,d2,d3;
float f1,f2,f3;
long int l1,l2,l3;

double fcross(int i, int j)
{  double l;
   l = i*j;
   return(l);
}
long int lcross(int i, int j)
{  long int l;
   l = i*j;
   return(l);
}

void main(void)
{
   x = sqrt(y);             
   x = sqrt(fcross(y,z));
   x = sqrt(lcross(y,z));
   f1 = sin(f2);
}
=================================================
필요한 테스트 프로그램은 각자 만들어 보기 바라며 실수의 계산이나 삼각
함수의 계산이 모두 가능하다.  사용가능한 함수는 math.h등의 각종 헤더화
일을 보면 알 수 있는데 SIN, COS등은 물론이고 ASIN, ACOS등의 함수도 준
비되어있다.
이제 컴파일과 링크를 할 차례이다.
일단 어셈화일을 먼저 어셈블 한다.

C:\WORK>A8096 TEST_ASM.ASM TEST_ASM TEST_ASM

아무래도 C 컴파일과 링크 과정은 자주할 것이므로 다음과 같이 BAT 화일을
 하나 만들어 놓는것이 편하리라 본다.
===================================================================
C96.bat
====================================================================
icc8096 %1.c96 -z30,60 -l %1 -q -P -r0 -S -x -a %1.asm
if errorlevel=1 goto end
xlink %1 TEST_ASM -f lnk8096 -o %1 -l %1.map -x
hexbin %1.a15 %1.bin i
re %1.bin 2 240
:end
===================================================================
-z30,60 : CPU 내부램의 30H 번지부터 60바이트를 컴파일러가 사용하도록 
        함. 이렇게 하면 함수내부의 지역 변수가 내부램으로 할당되어
        수행 속도가 빨라짐.
-a %1.asm : 컴파일 된 어셈 리스트를 생성함. 필요없음 지워도 됨.
            -q 옵션을 붙이면 리스트 화일에 어셈 코드가 같이 나옴.
    컴파일러의 효율이 그리 좋은편이 못되므로 일단 어셈화일을 생성하고
    속도가 요구되는 부분(인터럽트 루틴등)을 수정해서 다시 어셈블하는것
    도 좋을것이라 생각됨.  물론 실력이 붙어야 할 수 있겠지만...
기타 컴파일 옵션은 icc8096만 치면 화면에 자세히 설명이 나옴.    
xlink에서 "-f lnk8096"은 링크 컴멘드 화일을 지정하는 것으로 링크시에 
필요한 옵션사항들을 나열한 것임.  
위의 bat화일은 롬 애물단지를 사용한 경우로서 마지막의 re는 롬 애물 
기동명령임.  
==============================================================
LNK8096.XCL
=============================================================
-c8096
-Z(CODE)CSTART,CODE,RCODE,CDATA,ZVECT,CONST,CSTR,CCSTR=2000  
-! 롬의 시작번지는 2000H -!
-Z(DATA)DATA,IDATA,UDATA,ECSTR,WCSTR,TEMP,CSTACK=8000
-! 이경우 램의 시작번지는 8000H 하드웨어에 맞도록 조정하여야 함 -!
-e_medium_read=_formatted_read
cl8096
-!  -e_small_write=_formatted_write    
    위의 줄을 쓸경우 printf에서 실수는 사용하지 못함. 
    대신 메모리가 절약됨(롬/램 모두)
-!
=============================================================
xcl화일에서 -! 는 C에서의 /*, */ 와 같은 기능을 가짐.
bat와 xcl, C Source 가 준비되었으면 bat화일로 컴파일/링크/실행
을 시킴.

C:\WORK\>C96 TEST

==== 사족 ====
 
- A8096.EXE와 ICC8096.EXE가 있는 DIRECTORY는 PATH로 지정하는것이 편하다.
- 다음명령을 AUTOEXEC.BAT에 넣어두면 라이브러리와 INCLUDE화일이 작업 
   디렉토리에 없어도 된다.

    set C_INCLUDE=c:\iar\inc\
    set XLINK_DFLTDIR=c:\iar\lib\
                
            ** C:\IAR\INC\   <<== *.H 가 있는 디렉토리
            ** C:\IAR\LIB\   <<== *.R* (LIBRARY)가 있는 디렉토리

- IAR에서나온 8096 C COMPLIER MANUAL은 매우 부실하므로 굳이 구하려 
 들지말고 차라리 8051 COMPLIER MANUAL을 구해 보는것이 훨씬 자세하다.

