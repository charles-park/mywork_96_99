

#114   디지탈   (k2dig   )
V25 관련 자료 SP.24 #3-1                     03/05 16:44   142 line

본 글은 디지탈 동호회 마우스란의 여러회원분들께서 V25 관련 
일본서적을 여러 사람들과 같이 보기위하여 공동 번역한 내용입니다.
===================================================================

제3장

 +---------------------+
 | 스테핑모터에 관해서 |
 +---------------------+
 스테핑모터는 일명 펄스모터로  불리어지는 디지탈 콘트롤러에 적당한 모
터이다.스테핑모터는 프린터와  플로피디스크 드라이버에도 많이 사용되고 
있다.
 이장에서는 마이컴의  활용예로써 수요가 많게 생각되어지는  스테핑모터
를 구동하는 프로그램을 만들어  본다.  우선 처음에 스테핑  모터의 원리
를 간단히   설명도록 한다.  스테핑모터에는 2상,4상,5상 스테핑모터등이 
있다. 여기서는 대표적인  4상 스테핑 모터에 대해서 설명하겠다.4상 스테
핑모터의 컨트롤을 생각하는 방법은  5가지가 있다.
 그림 3-1은 스테핑 모터의  원리도이다. 회전자는 영구자석으로  되어 있
고, 고정자는 철심에 코일을   감은 것을 말한다. 그 고정자의 코일에는 A
상, /A상, B상,  /B상의 4상이 있다. 이것이 4상모터라고 불리어지는 이유
이다. 각상의 코일 리드선은 외부에 그대로 나가고 있다. 그리고 외부회로
에서 각상에 흐르는 전류를 순서적으로 ON-OFF 하는 것으로 모터의 구동을 
행한다. DC모터에서는 브러쉬축의 회전에 대응해서  코일에 흐르는 전류를 
전환하지만 스테핑모터는 외부의 스위치로 그 역할을 대신하고 있다.
 스테핑 모터의 구동회로를 그림 3-2-A,B 와 같이 나타낸다. 구동방법에는 
1상여자, 2상여자, 1-2상 여자등의  방법이 있다. 1상 여자는 그림 A와 같
이 A상,B상, /A상, /B상 한번에 1상씩 여자하는 방법이다. 1,2,3,4,1의 순
서로 여자를 반복하는 것으로 회전하고 있다.2상여자는 그림 B와 같이 A+B
상,   B+/A상, /A+/B상,  /B+A상으로 한번에 각각의  상에 전류를 흘린다. 
A,B,C,D,A라는 순번으로 여자를  반복하고 있다. 2상여자는 한번에 두개의 
상에 전류를 흘리기 위해서  회전토크가 크다.또한 1-2상 여자는 1상 여자
와 2상 여자를 반복해서 A,B 양 그림의 1,A,2,B,3,D,1,A 순번의 여자를 행
하고 있다. 그림의   예에서는 1상여자,2상여자의 스텝각(1회의 회전각도)
는 90도이지만1-2상에서는 스텝각이  45도로 정밀한 것이 특징이다.실제의 
스테핑모터의 구조와 사양은 그림 3-3-A~C와 같다.그림의 스테핑모터의 스
텝각은 1.8도로 되어  있지만, 이것은 2상여자의 경우이다. 이러한 스테핑
모터는 HB형의 스테핑모터라고 한다. 여기서  소개한 스테핑모터는 코일의 
저항을 고도로 극소화한 고속회전지향이다. HB형의 스테핑모터에는  5상으
로 스테핑각이 0.36도 인것이 있고, 4상 스테핑모터보다 스텝각이 작게 되
어져 있는 것이 특징이다.또한 스테핑모터의 타입으로서 PM형이 있다.
 그림 3-4  이것은 스텝각을 수십도로 만든  것으로 HB형의 모터보다 소형 
소토크이다. 이장에서 예제로 드는 것은 스테핑모터인 PM형이다.

 +---------------------+
 | 스테핑모터 구동회로 |
 +---------------------+
 스테핑모터구동회로의 기본은 그림 3-5A와 같이 되어 있다. 4개의 코일은 
TR1-TR4까지 ON-OFF로서 코일에 있는 전류를 제한하고 있다.

●플라이휠 다이오드의 동작
 스테핑 모터의 코일에   흐르는 전류에는 역기전력이 발생한다. 그  전압
에 대해서 스위칭 소자가  파괴되어지는 것을 막기  위해 적용되어지는 것
이 D1-D4이다.
 릴레이등의 코일에 흐르는  전류를 ON-OFF하기 위해서 발생시키는 서지전
압을 흡수하기  위한 다이오드는 그림 3-5-B와 같이 접속하는 것이 일반적
이다.스위치에서 코일L의 전류를 OFF한  순간  L의 B단에 고전압이 발생한
다. 이것은  코일에 축적된 에너지 때문이며,  이로 인해 발생되는 전류를 
방지하기 위한 것이다.
 여기서 D를 코일에 병렬로 접속하는  것은 다이오드가 전류를 바이패스할 
수 있기 때문이다. B단에 발생하는 고전압을 방지할 수 있다.

 - 댐퍼저항의 역할
 플라이휠 다이오드는 코일에  병렬로 접속되어져  있으면, 코일에 가해지
는 전압이 계속 흐르려고 한다. 그 결과로써 코일에 흐르는 전류를 계속적
으로 바꿀 수가  있다. 바꾸어 말하자면 모터를  빠르게 회전시킬 수가 있
다. 여기서 스위칭 소자가 견디어 낼 수 있는 전압이 발생되어지는 범위에
서 플라이휠 다이오드로 흐르는  전류를 제한하는 저항을 다이오드에 직렬 
접속한다.
 이 저항을 댐퍼저항이라고 한다. 특히 소형의 모터를 저속으로 구동할 경
우에는 댐퍼저항을 사용하지 않는 경우도 있다.

 - 스테핑 모터를 고속으로 회전하기 위해서는
 스테핑모터를 고속으로 회전하기  위해서는 고속으로 흐르는 전류를 빠르
게 절환할 필요가 있다.  전류를  빠르게 OFF하기 위해서는 고내압의 스위
칭 소자를  사용해서 댐퍼저항의 값을 크게 한다.
 또한 코일에 흐르는 전류의  상승을 빠르게 하기 위해서는 코일에 흐르는 
전류의 상한치를 높게할 필요가 있다.

 - 정전압회로
 그러기 위해서는 코일과  직렬로 전류제한저항을 접속하고 모터코일에 흐
르는 전류를 제한할 경우가  있다. 그림 3-5-C 이러한  코일의 정격전압에 
대해서 2배 이상의 전원접압을 사용할 수가 있고, 전류의 상승시간을 단축
시킬  수가 있다.
 스테핑 모터의  카탈로그에서는  정전압회로  라고 불리어지고 있습니다. 
그러나, 이러한 회로에서는 코일의 정격전압에 대해서 높은 전원전압을 사
용하면 할수록 저항에서 소모되는  전류가 크게 되고, 무한한 전류가 소모
되어지게 된다.또한 저항에서 발생하는  열의 처리도 문제가 된다. 때문에  

정전압회로를 사용하는 것은 보다 초소형의 스테핑모터의 구동회로이다.

 - 모터용 IC
 이상적인 회로로서는 코일에   대해서 충분히 높은 전압을 가하고,  전류
의 스위칭을 빠르게 하기  위해서 일정의 전류가 되도록 스위칭을 해서 전
류제한을 하는 회로이다.바꾸어 말하자면 스위칭 레귤레이터를 전원회로에  

사용하게 된다. 스위칭  방식의  스테핑모터 구동회로는 복잡하지만, 전용
의 IC를 사용하는 것으로 간단한 회로를 구성할 수가 있다.
 HB형의 스테핑모터를 고속으로  회전시키기 위해서 어플리케이션을  사용
할 수가  있고, 그림 3-6(SLA7020M:SANKEN전기)와  같은 사양의 전용 IC가 
있다. 이 IC를 사용해서 1.5A까지의 전류를 제어할수도 있고, 전류제한 회
로를 내장하고 있고, CR을   외부에서 부착할 수도 있다. 또한 스위칭소자
에 FET를 사용하기 때문에 소형이고 발열량도 작다.
 외형은 방열판 부착의  ZIP(ZIGZAG IN-LINE PACKAGE : 사진 3-2),  입력신
호는 2개, 그림  3-6-E와 같이 SEQUENCE로 2상여자의 구동을 행한다. 하드
웨어도 SEQUENCE처럼 된다. 이  IC는 2상 여자 전용이라고 생각하면 된다. 
이 IC를 사용한  실제회로가 그림 3-7이다. 실험에  사용한  IC는 UPP(8장 
참조)포트 2개로 구동펄스신호를  발생하고, 다른 한개의  포트는 PWM출력
으로 전류제어신호를 발생시킨다.
 소형의 PM스테핑모터를 잘  회전시키기 위해서는 플라이휠 다이오드 내장
의  트랜지스터 어레이를 사용해서 그림 3-8-A와 같은 간단한 회로를 이용
할 수  있다. 여자 SEAUENCE는 그림 3-9와 같다. 여기서 대상으로 하는 하
드웨어는 메카트로  트레이닝  보드이다.(그림 6-1-B) 이  보드는 CPU보드
로도 중요하게 사용되고 있다. UPP의 출력을 우선 AC04로 받고 트랜지스터 
어레이에서 스테핑모터를 구동하고 있다. AC04를 사용한 것은  소비전류가 
작고,출력전류를 크게 할  수 있기 때문이다.(최대 24mA) 사용한 스테핑모
터는  DC5V로 동작하고 코일 각가의  전류는 100mA이하이기 때문에 간단한 
회로로도 충분하다. 회로에서는  스테핑모터를 2개 접속할 수  있지만, 프
로그램에서 사용하고  있는 것은 UPP의  출력포트 UU0-UU4까지 접속되어진 
단방향의 모터뿐이다.

 +----------------+
 | 프로그램 사양  |
 +----------------+
 여기서 이제부터 만들어지는 프로그램의 사양은 기본적이기 때문에, 그대
로 구체적인  어플리케이션에 적용할 수 있다.  여기서는 기초 트레이닝에 
관해서 응용이 효과적이 될  수 있는 테마에 관해 다양한 프로그램을 소개
한다.

 - 사양
  속도를 결정하기 위해서  일정량의 회전을 행한다.일단 회전속도를 정
해서 일정량의 회전을 시켜본다. 실제의 스테핑 모터 구동회로에서는 많은 
경우 가속,  고속회전,  감속을 행한다.  이것은 탈조(모터를  제어펄스에 
로터가 따라가지 못하고 또는 외력으로 코터가 회전이 불가능하게  되는등 
정상적인 회전을 할  수 없는 상태)하지 않도록  고속제어를 할 필요가 있
다.

  고속과 이동량은  콘솔에서 파라메터로 주어진다.이동량과 스타트운동
의 두가지 파라메터는  콘솔에서 부여되어진다. 각각의 파라메터는 다음과 
같이 주어진다.
 속도 : 1초당 펄스수 (PPS)
 이동량 : 총 펄스수 (PULSE)



#115   디지탈   (k2dig   )
V25 관련 자료 SP.24 #3-2                     03/05 16:46   221 line


 +---------------------------------------------------------+
 | 소프트웨어 루프와 보드에 있는 스테핑 모터 구동 프로그램 |
 +---------------------------------------------------------+
 - 개요
 스테핑모터의 절환시퀀스는 소프트웨어로  행한다.  바꾸어 말하자면 CPU
의 내부에서  데이타를 조작하고  절환하기 위한 패턴을  만들고,  포트의 
1BIT씩 스테핑모터의 각상을 직접 제어한다.
 실제 응용에서는 상 절환의 시퀀스는 하드웨어로 행할 경우가 많고, 스테
핑모터 드라이버와 전용 IC는  2개의 입력으로  4상의 절환 신호를 발생한
다. 하드웨어를 사용하는 잇점은  입력신호의 수가 작게 되어지는 것과 소
프트웨어에 비해서 보다 고속의 스위칭이 가능하게 되기 때문이다. 그러나 
포트의 4BIT를 사용해서  소프트웨어로 여자시퀀스를 절환하는 것도 잘 사
용되어진다.
 스위칭을 소프트웨어로 사용하는  방식의 잇점은 어셈블러와도 적용할 수
가 있고, 이것은  C언어로써 처리할 수 있는  장점이 있다. 모터의 속도를 
정하기 위한 타이밍에는 소프트웨어  루프를 사용한다. 물론 정밀한  타이
밍을 결정하기 위해서는  프로그램의 스  계산,또는 실제측정에 있어서의 
파라메터의 변화가 필요하다.   그러나 이러한 방법은 다음에 설명할 방법
의 기초가 된다.

 - 프로그램 예와 해설
 리스트 3-1이 실제의  프로그램이다. 프로그램의 처음에 인클루드라는 벡
터화일을 리스트 3-2에  나타낸다. 또한 콘솔에서 회전속도와 회전량을 입
력하면,   스테핑모터를 회전시키는 입력을 얻을  수 있다. 우선 콘솔에서 
회전속도와  회전량을  입력시킨다. 입력이 끝나면 스테핑모터를 회전시켜
보고 원하는 회전량을 얻을때까지 입력을 반복한다.
 이   프로그램에서는  소프트웨어로   타이밍을   만들고,  파라메터로서 
TIME_CONST를 정의한다.  어셈블러루틴에서는 이러한 파라메터를 설정하기 
위해 루프간의  명령스  수를 계산하고,  각각의 명령실행시간을 합계내어 
전체루프실행시간을 구하는   테크닉도 있지만,  C로 만든 프로그램에서는 
한번 어셈블러로  출력하지 않으면, 실제명령의 실행시간을   알 수 없다. 
그래서 8086계열을 16BIT  CPU에서는 명령을 효율적으로 처리하기위해  파
이프 라인을 이용하고 있다.  따라서 실행시간 계산이 어렵다. 그러나  가
장 객闢한 루프의 실행시간을  측정하는 방법이 있다. 그것은 실제의 루프
를 많은   횟수 실행시켜보고 그 시간을   측정하고 1회실행시간을 구하는 
방법이다. 조금은 원시적인 것이 간단한 방법일 수도 있다. 이러한 방법으
로 구해진 파라메터에는 어느정도의  오차를 각오하지 않으면 안된다.  그
러나, 어셈블러  명령의 실행시간을 계산할 수  있는것은 초기 8BIT CPU를 
사용한 간단한 하드웨어에서나 가능하다. 예를 들면 DMA를 사용한 시스템, 
인터럽트를 사용한  시스템, 억세스 타이밍에 있어서  웨이트 길이가 다른 
디바이스를 접속한  시스템에서는 명령의  실행시간은 불확실하다. 그리고 
그러한 경우에는 타이머 인터럽트등의 하드웨어를 사용한 타이밍의 조정이 
확실히 필요하다. 이러한 예는 다음에 설명한다.
 우선 측정정밀도를 올리기  위해서 가능한한 많은 횟수를 반복한다. 시간
측정으로는 C의 TIME함수를  이용한다. 보통 MS-DOS에서는 1초단위 시간만
을 지원하지만, 여러분이 사용하는 컴퓨터의 메인보드에는 리얼타임클럭이 
탑재되어 있기 때문에 NMI를 이용해 1/100초 단위가 사용가능하다. 보드상
에서는 TIME함수가 제공되어지고  있지만, 콘솔의 표시를 보면서 스톱워치
로 시간을 계산한다는  것은 불가능하다.우선 TIME_CONST를 100000으로 하
고 1PPS로  10PULSE를 회전시키는 시간을 측정한다. 그리고, 그 시간을 10
초가 되도록 TIME_CONST를 조정한다.





 +---------------------------------------------------+
 | 인터럽트와 보드를 사용한 스테핑모터 구동 프로그램 |
 +---------------------------------------------------+
 타이밍 조정을 위해 타이머 인터럽트를  사용한다. 타이머 인터럽트를 사
용하면 운전속도를 정확히 제어할 수 있다. 우선  소프트웨어의 부담도 작
게 되기 때문에 모터를 제어하면서 스위칭입력을 감시하기도 하는 다른 처
리를할 수 있다.
 바꾸어 말하면 인터럽트를 사용한 장점은  정확히 타이밍과 소프트웨어의 
여유라고 말할 수 있다.  인터럽트를 사용한다는 것은 왠지 모르지만 고급 
프로그래밍 테크닉인것 같지만, 인터럽트 루틴은 보통 프로그램 보다도 간
단하다. 메인 루틴과의 파라메터 교환과 하드웨어 타이밍에 의존하는 부분
을 이해하는 것 뿐이다.
 이장에서 설명한 것과 같이  C를  사용해서 printf 디버거를 잘 활용하면 
디버그가 어렵다는 인터럽트에도 간단히  사용할 수 있다.  C를 잘 사용하
기 위해서는 소프트웨어의  스피드뿐만 아니라 인터럽트를 잘 활용한 밸런
스가 좋은 소프트웨어의 설계가 중요하다.

 - 프로그래밍 예와 해설
 리스트 3-3이 인터럽트를  사용한  스테핑모터구동 프로그램이다. 펄스를 
출력하는 함수는 앞에서와 같이  그대로이다. 인터럽트 함수로  하기 위해
서는 함수정의에 interrupt  라고 하는 예약어를 첨가한다. 이렇게하면 함
수 입구에서  전체 레지스터를 대피시키고 나갈때 다시 복구하게 된다.
 인터럽트 함수는  일반적으로 호출을 행할  수는 없다. 그리고, 인터럽트 
함수는 iret 명령으로 리턴하므로 보통 함수와는 리턴하는  시퀀스가 다르
고, 별도의  소스화일로 씌어진 함수이므로,  호출되어지기 위해서는 필히 
프로토타입 선언을 행하지 않으면 안된다.
 인터럽트  함수의 파라메터를  직접적으로  전달할 수는    없기 때문에, 
global변수를 사용해서  회전제어를 행한다.  변수펄스는 인터럽트 함수를 
제어하기 위한 파라메터이다. 인터럽트 함수는 타이머가 카운트 업하기 위
한 일정한 간격으로 기동되어 진다. 펄스가 0일때는 인터럽트 함수는 스테
핑모터를 회전시킬 수 없다. 펄스를 1이상이 되도록 인터럽트 함수를 기동
시키기 위해서  모터를  1pulse/분  회전시키고, 펄스를 decrease 시킨다. 
그리고, pulse가 0이 되면 모터를 정지시킨다. 바꾸어 말하면, 메인루프에
서 펄스에 셋트한  펄스수만큼 모터를 회전시킬 수가 있게 된다.
 모터의 회전 속도는 CPU에  내장된 타이머에 셋트된 값으로 결정된다. 타
이머의 입력 클럭은 62.5 KHz이기 때문에 PPS가 1초가 되도록 하기 위해서
는 TIME_CONST가 62500이 된다.메인  루프에서는 펄스를  0이 될때까지 몇
번이고 기다리고  있지만,  이러한 인터럽트를 사용하면 메인 루틴에서 별
도의 처리를 행하고 있어도 일정한 속도로 모터를 회전시킬 수가 있다.

<리스트 3-1>
/* 스테핑모터 구동 프로그램 */
#include <stdio.h>
#include <dos.h>
#define Ver_B10
#include <V25.H>

#define TIME_CONST 59170

int count = 0;          /* 상절환용 카운터 */
int direction = 0;      /* 회전방향 + 1:CW 0:STOP - 1:CCW */
long pps;               /* 회전속도 : PPS */
long pulse;             /* 이동구간 : 펄스수 */

void starttimer(void)
{                       /* 1/100초 클럭을 기동 */
        struct time t;

        t.ti_hour = 0;
        t.ti_min = 0;
        t.ti_sec = 0;
        t.ti_hund = 100;
        settime(&t);
}

disptime()
{                       /* 시간을 표시 */
        struct time t;
        gettime(&t);
        
printf("%02d:%02d:%02d:%02d\n",t.ti_hour,t.ti_min,t.ti_sec,t.ti_hund);
}

/* 여자 패턴을 절환하기 위한 배열 데이타 */
char led[]={0x03,0x06,0x0c,0x09)

void pout(void)
{                                    /* 스테핑모터 구동 펄스를출력 */
     byte d;

     if(0 < direction){
        count++;
        if (count>3){
            count=0;
        }
     }else if(direction <0) {
        count--;
        if (count<0){
            count=3;
        }
     }
     d = peekb(UPP_SEG,UR_PORT1) & 0xf0;
     pokeb(UPP_SEG,UR_PORT1,led[count] | d);
}

#define PULSE 0xffff            /* 펄스 1 : 펄스 입출력 포트 0번 */
#define PORT 0
int val_ur_ucer=                /* UR_UCER 설정하는 값 */
    0x0001 & PORT               /* U0 */
|0x0002 & PORT               /* U1 */
   |0x0004 & PORT               /* U2 */
   |0x0008 & PORT               /* U3 */
   |0x0010 & PORT               /* U4 */
   |0x0020 & PORT               /* U5 */
   |0x0040 & PORT               /* U6 */
   |0x0080 & PORT               /* U7 */
   |0x0100 & PORT               /* U8 */
   |0x0200 & PORT               /* U9 */
   |0x0400 & PORT               /* U10 */
   |0x0800 & PORT               /* U11 */
   |0x1000 & PORT               /* U12 */
   |0x2000 & PORT               /* U13 */
   |0x4000 & PORT               /* U14 */
   |0x8000 & PORT               /* U15 */
;
/* DOUT(1):출력 DIN(0):입력 */
int val_ur_ddr=         /* UR_DDR의 설정하는 값 */
    0x0001 & DOUT               /* U0 */
   |0x0002 & DOUT               /* U1 */
   |0x0004 & DOUT               /* U2 */
   |0x0008 & DOUT               /* U3 */
   |0x0010 & DOUT               /* U4 */
   |0x0020 & DOUT               /* U5 */
   |0x0040 & DOUT               /* U6 */
   |0x0080 & DOUT               /* U7 */
   |0x0100 & DIN                /* U8 */
   |0x0200 & DIN                /* U9 */
   |0x0400 & DIN                /* U10 */
   |0x0800 & DIN                /* U11 */
   |0x1000 & DIN                /* U12 */
   |0x2000 & DIN                /* U13 */
   |0x4000 & DIN                /* U14 */
   |0x8000 & DIN                /* U15 */
   ;

void initial()          /* UPP 초기화 */
{
   pokeu(UR_UCER,val_ur_ucer);  /* 펄스 입출력 */
   pokeu(UR_DDR,val_ur_ddr);    /* 입출력을 설정 */
}

void main()
{
   long i,j;
   initial();
   count = 0;
   direction = 1;
   starttimer();
   for(;;){
       printf("\n 회전 속도 (pps)>");
       scanf("%ld",&pps);
       printf("\n 이동 거리 (pulse)>");
       scanf("%ld",&pulse);
       pps = TIME_CONST / pps;
       printf("\n START:");
       disptime();
       for (i=0;i < pulse; i++) {
                pout();
                for(j=0; j < pps; j++);
                }
                printf("STOP :");
        disptime();
          }
}


#116   디지탈   (k2dig   )
V25 관련 자료 SP.24 #3-3                     03/05 16:50   159 line

<리스트 3-2> V25.H 의 내용
/*
V25 내부 레지스터 정의 벡터
FOR TURBO-C V2.0 과
V25 CPU BOARD SERIES

** EDITION NUMBER   **** DATE  ****      AUTHOR
  FIRST             87/10/31        KENJI MUGITA
                    88/07/10
                    88/09/17        인터럽트 벡터 정의를 숫자로 변경
  1.1               88/10/05
  1.2               89/04/15
  2.0               90/02/24        버젼 관리를 위해서 UPP.H와 같이 한
다.
  3.32              90/05/10        B10 의 정의를 추가
  3.32      90/05/14        BYTE,WORD 의 정의를 추가
(주의)
이 벡터 화일은 V25 CPU  BOARD 위에서 TURBO-C를 사용하기 위해서 만든 것
임.
다른 하드웨어 또는 다른 COMPILER로  V25 CPU 를 사용할 경우는 내용을 확
인할것.

참고,인용문헌
uPD70322,uPD70320 USER'S MANUAL 일본전기
HD63140 UPP DATA BOOK           히다찌제작소
**********************************************************************
*******/
/* 버젼의 정의 모니터와 하드에 대응해서 설정한다. */

typedef unsigned        char    byte;
typedef unsigned        int     word;

#define WAIT_0 0        /* wait control */
#define WAIT_1 1        /* 1state */
#define WAIT_2 2        /* 2state */
#define WAIT_3 3        /* enable READY */
#define BLOCK_0 0x0001  /* 00000 - 1FFFF */
#define BLOCK_0 0x0004  /* 20000 - 3FFFF */
#define BLOCK_0 0x0010  /* 40000 - 5FFFF */
#define BLOCK_0 0x0040  /* 60000 - 7FFFF */
#define BLOCK_0 0x0100  /* 80000 - 9FFFF */
#define BLOCK_0 0x0400  /* A0000 - BFFFF */
#define BLOCK_0 0x1000  /* C0000 - FFFFF */
#define BLOCK_0 0x4000  /* I/O */

/* 다음의 정수는 하드웨어에 의존한다. 보드에 대응해서 변경할 것.*/

#ifdef MAIN
extern int _stksize = 0x300;
extern int _headlen = 0x10;
#endif

#if defined(MON_33)

#define MON_Version "Ver 3.3"
#define MON_CS   0xf800                 /* 코드 세그먼트 */
#define MON_COLD 0                      /* 모니터 스타트 오프셋 */
#define MON_WARM 0                      /* 상동 */
#define MON_ABT  0                      /* ABORT 스타트 오프셋 */

#elif defined(MON_33S)

#define MON_Version "Ver3.3S"
#define MON_CS   0xfa00                 /* 코드 세그먼트 */
#define MON_COLD 0                      /* 모니터 스타트 오프셋 */
#define MON_WARM 0                      /* 모니터 스타트 오프셋 */
#define MON_ABT  0                      /* ABORT 스타트 오프셋 */

#elif defined(MON_34)

#define MON_Version "Ver3.4"
#define MON_CS   0xf800                 /* 코드 세그먼트 */
#define MON_COLD 0                      /* 모니터 스타트 오프셋 */
#define MON_WARM 0          /* 모니터 스타트 오프셋 */
#define MON_ABT  0                      /* ABORT 스타트 오프셋 */

#elif defined(MON_34S)

#define MON_Version "Ver3.4S"
#define MON_CS   0xfa00                 /* 코드 세그먼트 */
#define MON_COLD 0                      /* 모니터 스타트 오프셋 */
#define MON_WARM 0                      /* 모니터 스타트 오프셋 */
#define MON_ABT  0                      /* ABORT 스타트 오프셋 */

#endif

#if defined(Ver_11)

#define CPU_Version "CPU Version A1.1"
#define UPP_SEG   0x1000

#elif defined(Ver_A20)

#define CPU_Version "CPU Version A-20"
#define UPP_SEG   0x2000      /* UPP 세그먼트 어드레스 */
#define RTC_SEG   0xb000      /* REAL-TIME-CLOCK 세그먼트 (DUMMY) */
#define RAM_END   0x1000      /* RAM 최후의 세그먼트 어드레스 */
#define ROM_START 0xf000      /* ROM 스타트 세그먼트 어드레스 */
#define USR_START 0x100       /* USER AREA 스타트 세그먼트 어드레스 */
#define RAM_SIZ  (RAM END-USR_START)    /* RAM 영역의 사이즈 */
/* WAIT CONTROLLER 의 초기치 */
#define WTC_VAL (BLOCK_0 * WAIT_1 + \   /* 00000 - 1FFFF */
                 BLOCK_1 * WAIT_3 + \   /* 20000 - 3FFFF */
                 BLOCK_2 * WAIT_3 + \   /* 40000 - 5FFFF */
                 BLOCK_3 * WAIT_3 + \   /* 60000 - 7FFFF */
                 BLOCK_4 * WAIT_3 + \   /* 80000 - 9FFFF */
                 BLOCK_5 * WAIT_3 + \   /* A0000 - BFFFF */
                 BLOCK_6 * WAIT_2 + \   /* C0000 - FFFFF */
                 BLOCK_7 * WAIT_3)      /* I/O */

#elif defined(Ver_B10)

#define CPU_Version "CPU Version B-10"
#define UPP_SEG   0xa000      /* UPP 세그먼트 어드레스 */
#define RTC_SEG   0xb000      /* REAL-TIME-CLOCK 세그먼트 (DUMMY) */
#define RAM_END   0x2000      /* RAM 최후의 세그먼트 어드레스 */
#define ROM_START 0xe000      /* ROM 스타트 세그먼트 어드레스 */
#define USR_START 0x100       /* USER AREA 스타트 세그먼트 어드레스 */
#define RAM_SIZ  (RAM END-USR_START)    /* RAM 영역의 사이즈 */
/* WAIT CONTROLLER 의 초기치 */
#define WTC_VAL (BLOCK_0 * WAIT_0 + \   /* 00000 - 1FFFF */
                 BLOCK_1 * WAIT_0 + \   /* 20000 - 3FFFF */
                 BLOCK_2 * WAIT_0 + \   /* 40000 - 5FFFF */
                 BLOCK_3 * WAIT_0 + \   /* 60000 - 7FFFF */
                 BLOCK_4 * WAIT_3 + \   /* 80000 - 9FFFF */
                 BLOCK_5 * WAIT_3 + \   /* A0000 - BFFFF */
                 BLOCK_6 * WAIT_1 + \   /* C0000 - FFFFF */
                 BLOCK_7 * WAIT_3)      /* I/O */

#elif defined(Ver_B98)

#define CPU_Version "CPU Version B-98"
#define UPP_SEG   0xa000      /* UPP 세그먼트 어드레스 */
#define RTC_SEG   0xb000      /* REAL-TIME-CLOCK 세그먼트 (DUMMY) */
#define RAM_END   0x2000      /* RAM 최후의 세그먼트 어드레스 */
#define ROM_START 0xc000      /* ROM 스타트 세그먼트 어드레스 */
#define USR_START 0x100       /* USER AREA 스타트 세그먼트 어드레스 */
#define RAM_SIZ  (RAM END-USR_START)    /* RAM 영역의 사이즈 */
/* WAIT CONTROLLER 의 초기치 */
#define WTC_VAL (BLOCK_0 * WAIT_0 + \   /* 00000 - 1FFFF */
           BLOCK_1 * WAIT_0 + \   /* 20000 - 3FFFF */
                 BLOCK_2 * WAIT_0 + \   /* 40000 - 5FFFF */
                 BLOCK_3 * WAIT_0 + \   /* 60000 - 7FFFF */
                 BLOCK_4 * WAIT_3 + \   /* 80000 - 9FFFF */
                 BLOCK_5 * WAIT_3 + \   /* A0000 - BFFFF */
                 BLOCK_6 * WAIT_1 + \   /* C0000 - FFFFF */
                 BLOCK_7 * WAIT_3)      /* I/O */

#endif
/* ************************************************************ */
/*               V25내부 레지스터등에 관한 정의                 */
/* ************************************************************ */
#define _V25BASE   (0xff00)
/*
V25 내부 어드레스 정의 : 실제 어드레스는 다음과 같이 나타낸다.
예: _V25BASE*16+_BANK0(BANK0의 어드레스)
이하의 정의로 사용하는 레이블은 V25의 매뉴얼에 수록되어 있으므로
하드웨어와 밀착된 것은 _를 붙여서 나타낸다.
*/


#117   디지탈   (k2dig   )
V25 관련 자료 SP.24 #3-4                     03/05 16:53   469 line


/* 내부 RAM 영역 : 레지스터 뱅크와 DMA 서어비스 채널 부 */

/* 레지스터뱅크0와 DMA/MACRO 서비스 채널 */
#define _BANK0     (0xE00)
#define _SAR0      (0xE00)
#define _DAR0      (0xE02)
#define _SARH0     (0xE04)
#define _DARH0     (0xE05)
#define _TC0       (0xE06)

/* DMA service channel1 */
#define _SAR1      (0xE08)
#define _DAR1      (0xE0A)
#define _SARH1     (0xE0C)
#define _DARH1     (0xE0D)
#define _TC1       (0xE0)
/* MACRO service channel2 */
#define _SFRP2     (0xE10)
#define _MSC2      (0xE11)
#define _SCHR2     (0xE13)
#define _MSP2      (0xE14)
#define _MSS2      (0xE16)
/* MACRO service channel3 */
#define _SFRP3     (0xE18)
#define _MSC3      (0xE19)
#define _SCHR3     (0xE1B)
#define _MSP3      (0xE1C)
#define _MSS3      (0xE1E)

/* 레지스터 뱅크 1과 DMA/MACRO 서비스 채널 */
#define _BANK1     (0xE20H)
/* MACRO service channel4 */
#define _SFRP4     (0xE20)
#define _MSC3      (0xE21)
#define _SCHR3     (0xE23)
#define _MSP3      (0xE24)
#define _MSS3      (0xE26)
/* MACRO service channel5 */
#define _SFRP5     (0xE28)
#define _MSC5      (0xE29)
#define _SCHR5     (0xE2B)
#define _MSP5      (0xE2C)
#define _MSS5      (0xE2E)
/* MACRO service channel6 */
#define _SFRP6     (0xE30)
#define _MSC6      (0xE31)
#define _SCHR6     (0xE33)
#define _MSP6      (0xE34)
#define _MSS6      (0xE36)
/* MACRO service channel7 */
#define _SFRP7     (0xE38)
#define _MSC7      (0xE39)
#define _SCHR7     (0xE3B)
#define _MSP7      (0xE3C)
#define _MSS7      (0xE3E)

/* 레지스터 뱅크 2 */
#define _BANK2     (0xE40)
#define _VECTOR2   (0xE42)
#define _FLAGBAK2  (0xE44)
#define _IPBAK2    (0xE46)
#define _DS2       (0xE48)
#define _SS2       (0xE4A)
#define _CS2       (0xE4C)
#define _ES2       (0xE4E)
#define _DI2       (0xE50)
#define _SI2       (0xE52)
#define _BP2       (0xE54)
#define _SP2       (0xE56)
#define _BX2       (0xE58)
#define _DX2       (0xE5A)
#define _CX2       (0xE5C)
#define _AX2       (0xE5E)

/* 레지스터 뱅크 3 */
#define _BANK3     (0xE60)
#define _VECTOR3   (0xE62)
#define _FLAGBAK3  (0xE64)
#define _IPBAK3    (0xE66)
#define _DS3       (0xE68)
#define _SS3       (0xE6A)
#define _CS3       (0xE6C)
#define _ES3       (0xE6E)
#define _DI3       (0xE70)
#define _SI3       (0xE72)
#define _BP3       (0xE74)
#define _SP3       (0xE76)
#define _BX3       (0xE78)
#define _DX3       (0xE7A)
#define _CX3       (0xE7C)
#define _AX3       (0xE7E)

/* 레지스터 뱅크 4 */
#define _BANK4     (0xE80)
#define _VECTOR4   (0xE82)
#define _FLAGBAK4  (0xE84)
#define _IPBAK4    (0xE86)
#define _DS4       (0xE88)
#define _SS4       (0xE8A)
#define _CS4       (0xE8C)
#define _ES4       (0xE8E)
#define _DI4       (0xE90)
#define _SI4       (0xE92)
#define _BP4       (0xE94)
#define _SP4       (0xE96)
#define _BX4       (0xE98)
#define _DX4       (0xE9A)
#define _CX4       (0xE9C)
#define _AX4       (0xE9E)

/* 레지스터 뱅크 5 */
#define _BANK5     (0xEA0)
#define _VECTOR5   (0xEA2)
#define _FLAGBAK5  (0xEA4)
#define _IPBAK5    (0xEA6)
#define _DS5       (0xEA8)
#define _SS5       (0xEAA)
#define _CS5       (0xEAC)
#define _ES5       (0xEAE)
#define _DI5       (0xEB0)
#define _SI5       (0xEB2)
#define _BP5       (0xEB4)
#define _SP5       (0xEB6)
#define _BX5       (0xEB8)
#define _DX5       (0xEBA)
#define _CX5       (0xEBC)
#define _AX5       (0xEBE)

/* 레지스터 뱅크 6 */
#define _BANK6     (0xEC0)
#define _VECTOR6   (0xEC2)
#define _FLAGBAK6  (0xEC4)
#define _IPBAK6    (0xEC6)
#define _DS6       (0xEC8)
#define _SS6      (0xECA)
#define _CS6       (0xECC)
#define _ES6       (0xECE)
#define _DI6       (0xED0)
#define _SI6       (0xED2)
#define _BP6       (0xED4)
#define _SP6       (0xED6)
#define _BX6       (0xED8)
#define _DX6       (0xEDA)
#define _CX6       (0xEDC)
#define _AX6       (0xEDE)

/* 레지스터 뱅크 7 : 통상 사용되어지는 레지스터 세트 */
#define _BANK7     (0xEE0)
#define _VECTOR7   (0xEE2)
#define _FLAGBAK7  (0xEE4)
#define _IPBAK7    (0xEE6)
#define _DS7       (0xEE8)
#define _SS7       (0xEEA)
#define _CS7       (0xEEC)
#define _ES7       (0xEEE)
#define _DI7       (0xEF0)
#define _SI7       (0xEF2)
#define _BP7       (0xEF4)
#define _SP7       (0xEF6)
#define _BX7       (0xEF8)
#define _DX7       (0xEFA)
#define _CX7       (0xEFC)
#define _AX7       (0xEFE)

/* 특수 레지스터 영역 */
/* I/O 포트와 콘트롤 레지스터
입출력 콘트롤 레지스터는 0:출력 1:입력
모드 콘트롤 레지스터는 0:포트 모드 1: 콘트롤 모드
*/
#define _P0        (0xF00)      /* 포트 0 레지스터 */
#define _PM0(0xF01)      /* 포트 0 입출력 콘트롤 레지스터 */
#define _PMC0      (0xF02)      /* 포트 0 모드 콘트롤 레지스터 */
#define _P1        (0xF08)      /* 포트 1 레지스터 */
#define _PM1       (0xF09)      /* 포트 1 입출력 콘트롤 레지스터 */
#define _PMC1      (0xF0a)      /* 포트 1 모드 콘트롤 레지스터 */
#define _P2        (0xF10)      /* 포트 2 레지스터 */
#define _PM2       (0xF11)      /* 포트 2 입출력 콘트롤 레지스터 */
#define _PMC2      (0xF12)      /* 포트 2 모드 콘트롤 레지스터 */
#define _PT        (0xF38)      /* 컴퍼레이터 입력 포트 */
#define _PMT       (0xF3b)      /* 컴퍼레이터 기준전압 콘트롤 */

#define UR_UDR     0x40         /* 데이타 레지스터의 선두 */
#define UR_UDR0    0x40         /* 데이타 레지스터 0 */
#define UR_UDR0H   0x40         /* 데이타 레지스터 0의 상위 바이트 */
#define UR_UDR0L   0x41         /* 데이타 레지스터 0의 하위 바이트 */
#define UR_UDR1    0x42         /* 데이타 레지스터 1 */
#define UR_UDR2    0x44         /* 데이타 레지스터 2 */
#define UR_UDR3    0x46         /* 데이타 레지스터 3 */
#define UR_UDR4    0x48         /* 데이타 레지스터 4 */
#define UR_UDR5    0x4A         /* 데이타 레지스터 5 */
#define UR_UDR6    0x4C         /* 데이타 레지스터 6 */
#define UR_UDR7    0x4E         /* 데이타 레지스터 7 */
#define UR_UDR8    0x50         /* 데이타 레지스터 8 */
#define UR_UDR9    0x52         /* 데이타 레지스터 9 */
#define UR_UDR10   0x54         /* 데이타 레지스터 10*/
#define UR_UDR11   0x56         /* 데이타 레지스터 11*/
#define UR_UDR12   0x58         /* 데이타 레지스터 12*/
#define UR_UDR13   0x5A         /* 데이타 레지스터 13*/
#define UR_UDR14   0x5C         /* 데이타 레지스터 14*/
#define UR_UDR15   0x5E         /* 데이타 레지스터 15*/
#define UR_UDR16   0x60         /* 데이타 레지스터 16*/
#define UR_UDR17   0x62         /* 데이타 레지스터 17*/
#define UR_UDR18   0x64         /* 데이타 레지스터 18*/
#define UR_UDR19   0x66         /* 데이타 레지스터 19*/
#define UR_UDR20   0x68         /* 데이타 레지스터20*/
#define UR_UDR21   0x6A         /* 데이타 레지스터 21*/
#define UR_UDR22   0x6C         /* 데이타 레지스터 22*/
#define UR_UDR23   0x6E         /* 데이타 레지스터 23*/

/* UR_USCR 에 설정하는 값 */
#define UPP_START  0x02         /* UPP START */
#define UPP_STOP   0x00         /* UPP STOP */

/* UR_CMR 에 설정하는 코맨드 */
#define UC_FRS  0x00            /* INPUT CAPTURE 부착 카운터 */
#define UC_INS  0x10            /* INPUT CAPTURE 부착 리셋 카운터 */
#define UC_UDS  0x20            /* UP-DN COUNTER (1PULSE 방향 신호) */
#define UC_GTS  0x30            /* GATE 제어 카운터 : 캡춰 리셋 부착*/
#define UC_FRC  0x40            /* OUTPUT COMPARE 출력 부착 카운터 */
#define UC_INC  0x50            /* COMPARE 기능 출력 인터벌 카운터 */
#define UC_PWC  0x60            /* PWM 신호 출력 카운터 */
#define UC_OSC  0x70            /* ONE-SHOT 펄스 출력 카운터 */
#define UC_FFC  0x80            /* 50% DUTY PULSE 출력 카운터 */
#define UC_TPC  0x98            /* 2상 펄스 입력 UP/DN 카운터 */
#define UC_GTC  0xA0            /* 게이트 폭의 대소 측정 */
#define UC_CTO  0xB0            /* 트리거 부착 ONE-SHOT 출력 */
#define UC_SIT  0xC0            /* SHIFT INPUT SERIAL 수신 */
#define UC_SOT  0xD0            /* SHIFT OUTPUT SERIAL 송신 */
#define UC_SPO  0xE0            /* DATA SHIFT 와 병렬 출력 */
#define UC_NOP  0xF0            /* NO OPERATION */

/* UR_CMR에 설정하는 코맨드와 조합해서 사용하는 값 */
#define UCM_TMR   0x00          /* 타이머 : 내부 클럭을 사용 */
#define UCM_CTR   0x08          /* 카운터 : 내부 클럭을 사용 */
#define UCM_INT   0x00          /* 내부클럭으로 쉬프트 */
#define UCM_EXT   0x08          /* 외부클럭으로 쉬프트 */
#define UCM_UP    0x00          /* UP-COUNT 선택 */
#define UCM_DWN   0x04          /* DN-COUNT 선택 */
#define UCM_NINV  0x00          /* UP-DN COUNTER 방향 제어 */
#define UCM_INV   0x04          /* UP-DN COUNTER 방향 제어 */
#define UCM_LOW   0x00          /* 출력 펄스 게이트 신호 극성 선택 */
#define UCM_HIGH  0x01  /* 출력 펄스 게이트 신호 극성 선택 */
#define UCM_RIGHT 0x00          /* 우측 쉬프트 선택 */
#define UCM_LEFT  0x04          /* 좌측 쉬프트 선택 */

/* UR_IORx 레지스터에 설정하는 값 */
#define UCM_UPEG  0x20          /* UP-EDGE 유효 */
#define UCM_DWEG  0x40          /* DN-EDGE 유효 */
#define UCM_UDEG  0x60          /* 둘다 유효 */

/* DDR1, DDR2 에 설정하는 값 */
#define DIN       0x0000        /* 입력 */
#define DOUT      0xFFFF        /* 출력 */

/* UCER 에 설정하는 값 */
#define PORT     0x0000        /* 포트 모드 */
#define PULSE     0xFFFF        /* 펄스 모드 */

/* 외부인터럽트 콘트롤 레지스터 */
#define _INTM   (0xF40)         /* 외부 인터럽트 모드 레지스터 */
#define _EMS0   (0xF44)         /* 매크로 서비스 레지스터 0 */
#define _EMS1   (0xF45)
#define _EMS2   (0xF46)
#define _EXIC0  (0xF4c)         /* 외부 인터럽트 제어 레지스터 0 */
#define _EXIC1  (0xF4d)
#define _EXIC2  (0xF4e)

/* 시리얼 포트와 콘트롤 레지스터 */
#define _RXB0   (0xF60)         /* 시리얼 채널 0 수신 레지스터 */
#define _TXB0   (0xF62)         /* 시리얼 채널 0 송신 레지스터 */
#define _SRMS0  (0xF65)           /* 시리얼 채널 0 수신 매크로 서비스 
제어 레지스터 */
#define _STMS0  (0xF66)           /* 시리얼 채널 0 송신 매크로 서비스 
제어 레지스터 */
#define _SCM0   (0xF68)         /* 시리얼 채널 0 모드 레지스터 */
#define _SCC0   (0xF69)         /* 시리얼 채널 0 클럭 선택 레지스터 */
#define _BRG0   (0xF6a)         /* 시리얼 채널 0 클럭 분주비 설정 레지
스터 */
#define _SCE0   (0xF6b)         /* 시리얼 채널 0 에러 레지스터 */
#define _SEIC0  (0xF6c)          /* 시리얼 채널 0 에러 인터럽트 레지스
터 */
#define _SRIC0  (0xF6d)          /* 시리얼 채널 0 수신 인터럽트 레지스
터 */
#define _STIC0  (0xF6e)         /* 시리얼 채널 0 송신 인터럽트 레지스
터 */
#define _RXB1   (0xF70)         /* 시리얼 채널 1 수신 레지스터 */
#define _TXB1   (0xF72)         /* 시리얼 채널 1 송신 레지스터 */
#define _SRMS1  (0xF75)           /* 시리얼 채널 1 수신 매크로 서비스 
제어 레지스터 */
#define _STMS1  (0xF76)           /* 시리얼 채널 1 송신 매크로 서비스 
제어 레지스터 */
#define _SCM1   (0xF78)         /* 시리얼 채널 1 모드 레지스터 */
#define _SCC1   (0xF79)         /* 시리얼 채널 1 클럭 선택 레지스터 */
#define _BRG1   (0xF7a)         /* 시리얼 채널 1 클럭 분주비 설정 레지
스터 */
#define _SCE1   (0xF7b)         /* 시리얼 채널 1 에러 레지스터 */
#define _SEIC1  (0xF7c)          /* 시리얼 채널 1 에러 인터럽트 레지스
터 */
#define _SRIC1  (0xF7d)          /* 시리얼 채널 1 수신 인터럽트 레지스
터 */
#define _STIC1  (0xF7e)         /* 시리얼 채널 1 송신 인터럽트 레지스
터 */

/* 타이머 콘트롤 레지스터 */
#define _TM0    (0xF80)     /* 타이머 레지스터 0 */
#define _MD0    (0xF82)     /* 모듈/타이머 레지스터 0 */
#define _TM1    (0xF88)     /* 타이머 레지스터 1 */
#define _MD1    (0xF8a)     /* 모듈/타이머 레지스터 1 */
#define _TMC0   (0xF90)     /* 타이머 콘트롤 레지스터 0 */
#define _TMC1   (0xF91)     /* 타이머 콘트롤 레지스터 1 */
#define _TMMS0  (0xF94)     /* 타이머 매크로 서비스 제어 레지스터 0 */
#define _TMMS1  (0xF95)     /* 타이머 매크로 서비스 제어 레지스터 1 */
#define _TMMS2  (0xF96)     /* 타이머 매크로 서비스 제어 레지스터 2 */
#define _TMIC0  (0xF9c)     /* 타이머 인터럽트 콘트롤 레지스터 0 */
#define _TMIC1  (0xF9d)     /* 타이머 인터럽트 콘트롤 레지스터 1 */
#define _TMIC2  (0xF9e)     /* 타이머 인터럽트 콘트롤 레지스터 2 */

/* DMA 콘트롤 레지스터 */
#define _DMAC0  (0xFa0)     /* DMA 콘트롤 레지스터 0 */
#define _DMAM0  (0xFa1) /* DMA 모드 레지스터 0 */
#define _DMAC1  (0xFa2)     /* DMA 콘트롤 레지스터 1 */
#define _DMAM1  (0xFa3)     /* DMA 모드 레지스터 1 */
#define _DIC0   (0xFac)     /* DMA 인터럽트 제어 레지스터 0 */
#define _DIC1   (0xFad)     /* DMA 인터럽트 제어 레지스터 1 */

/* 그외 콘트롤 레지스터 */
#define _STBC   (0xF94)     /* 스탠바이 제어 레지스터 */
#define _RFM    (0xF95)     /* 리플래쉬 모드 레지스터 */
#define _WTC    (0xF96)     /* WAIT 제어 레지스터 */
#define _FLAG   (0xF9c)     /* USER FLAG 레지스터 */
#define _PRC    (0xF9d)     /* PROCESSOR 제어 레지스터 */
#define _TBIC   (0xF9e)     /* TIME BASE INTERRUPT 제어 레지스터 */
#define _IDB    (0xFFF)     /* 내부 메모리 베이스 레지스터 */

/* 인터럽트 벡터 넘버의 정의 */
#define _INTDIVERR    0
#define _INTSSTEP     1
#define _INTNMI       2
#define _INTBRK       3
#define _INTBRKV      4
#define _INTCHKIND    5
#define _INTFPO       7
#define _INTSER0      12
#define _INTSR0       13
#define _INTST0       14
#define _INTSER1   16
#define _INTSR1       17
#define _INTST1       18
#define _INTINOUT     19
#define _INTD0        20
#define _INTD1        21
#define _INTP0        24
#define _INTP1        25
#define _INTP2        26
#define _INTTU0       28
#define _INTTU1       29
#define _INTTU2       30
#define _INTTB        31
#define _INT20        32
#define _INT21        33
#define _INT22        34

#define pokeV25reg(r,d)    pokeb(_V25BASE,r,d)
#define pokeV25regw(r,d)   poke(_V25BASE,r,d)
#define peekV25reg(r)     peekb(_V25BASE,r)
#define peekV25regw(r)     peek(_V25BASE,r)
#define setV25reg(r,d)     pokeb(_V25BASE,r,peekb(_V25BASE,r)|d)
#define resetV25reg(r,d)   pokeb(_V25BASE,r,peekb(_V25BASE,r)&d)
#define chgV25reg(r,d)     pokeb(_V25BASE,R,peekb(_V25BASE,r)^d)

#define retrbi _emit_(0x0f,0x91)
#define fint   _emit_(0x0f,0x92)
#define stop   _emit_(0x0f,0x9e)

/* UPP 내부 레지스터 어드레스
워드 데이타를 억세스 할때에는 데이타 순서를 주의 */
#define UR_DDR     0x00     /* 포트 입출력 방향 1:출력 0:입력 */
#define UR_DDR2    0x00     /* 리셋으로 0이 되고 입력모드로 된다. */
#define UR_DDR1    0x01
#define UR_PORT    0x02     /* 포트로써 사용할때의 레지스터 */
#define UR_PORT2   0x02     /* 처음이 상위 바이트 */
#define UR_PORT1   0x03     /* 나중이 하위 바이트 */
#define UR_WDTR    0x05     /* WATCH-DOG TIMER 레지스터 */
#define UR_ADCSR   0x06     /* A/D 콘트롤 상태 레지스터 */
#define UR_ADDR0   0x07     /* A/D 데이타 레지스터 0 */
#define UR_ADDR0H  0x07     /* A/D 데이타 레지스터 0 상위 바이트 */
#define UR_ADDR0L  0x08     /* A/D 데이타 레지스터 0 하위 바이트 */
#define UR_ADDR1   0x09     /* A/D 데이타 레지스터 1 */
#define UR_ADDR1H  0x09     /* A/D 데이타 레지스터 1 상위 바이트 */
#define UR_ADDR1L  0x0A     /* A/D 데이타 레지스터 1 하위 바이트 */
#define UR_ADDR2   0x0B     /* A/D 데이타 레지스터 2 */
#define UR_ADDR2H  0x0B     /* A/D 데이타 레지스터 2 상위 바이트 */
#define UR_ADDR2L  0x0C     /* A/D 데이타 레지스터 2 하위 바이트 */
#define UR_ADDR3   0x0D   /* A/D 데이타 레지스터 3 */
#define UR_ADDR3H  0x0D     /* A/D 데이타 레지스터 3 상위 바이트 */
#define UR_ADDR3L  0x0E     /* A/D 데이타 레지스터 3 하위 바이트 */
#define UR_RAMCR   0x0F     /* 램 제어 레지스터 1:허가 */
#define UR_UCER    0x10     /* 포트/펄스 입출력 선택 레지스터 */
#define UR_UCER2   0x10     /* 포트/펄스 입출력 선택 레지스터 2 */
#define UR_UCER1   0x11     /* 포트/펄스 입출력 선택 레지스터 1 */
#define UR_UOR     0x12     /* 펄스 출력 레지스터 */
#define UR_UOR2    0x12     /* 펄스 출력 레지스터 2 */
#define UR_UOR1    0x13     /* 펄스 출력 레지스터 1 */
#define UR_NDER    0x14     /* NDR ENABLE 레지스터 */
#define UR_NDR     0x16     /* NEXT DATA 레지스터 */
#define UR_USCR    0x20     /* 시스템 제어 레지스터 */
#define UR_MFNR    0x21     /* MAXIMUM FUNCTION 수 레지스터 */
#define UR_FNR     0x22     /* FUNCTION NUMBER 레지스터 */
#define UR_CMR     0x23     /* 커맨드 레지스터 */
#define UR_RASRA   0x24     /* 데이타 레지스터 선택 레지스터 A */
#define UR_RASRB   0x25     /* 데이타 레지스터 선택 레지스터 B */
#define UR_IOARA   0x26     /* 클럭 핀 선택 방향 설정 레지스터 */
#define UR_IOARB   0x27     /* 트리거 핀 선택 방향 설정 레지스터 */
#define UR_IOARC   0x28     /* 펄스 출력 핀 선택 레지스터 */
#define UR_IOARD   0x29     /* 게이트 입력 선택, 방향 설정 레지스터 */
#define UR_IER3    0x2A     /* 인터럽트 요구 제어 레지스터 3 */
#define UR_IER2    0x2B     /* 인터럽트 요구 제어 레지스터 2 */
#define UR_IER1    0x2C     /* 인터럽트 요구 제어 레지스터 1 */
#define UR_IRQR3   0x2D     /* 인터럽트 요구 레지스터 3 */
#define UR_IRQR2   0x2E     /* 인터럽트 요구 레지스터 2 */
#define UR_IRQR1   0x2F     /* 인터럽트 요구 레지스터 1 */
#define UR_ISR3    0x30     /* 인터럽트 상태 레지스터 3 */
#define UR_ISR2    0x31     /* 인터럽트 상태 레지스터 2 */
#define UR_ISR1    0x32     /* 인터럽트 상태 레지스터 1 */
#define UR_ISCR3   0x33     /* 인터럽트 상태 클리어 레지스터 3 */
#define UR_ISCR2   0x34     /* 인터럽트 상태 클리어 레지스터 2 */
#define UR_ISCR1   0x35     /* 인터럽트 상태 클리어 레지스터 1 */
#define UR_UIOR    0x36     /* 내부 I/O  레지스터 */

/* 이하 데이타 레지스터는 기본적으로 워드로 취급한다.
바이트 억세스를 할때는 어드레스 하위의 데이타(상위바이트)부터 억세스된
다.
예를 들면  UR_UDR0H를 억세스하면  UR_UDROL의 데이타가  래치되기 때문이
다.*/
/* 포트의 초기치 */
#define LOW  0x0000         /* 로우 레벨 */
#define HIGH 0xFFFF         /* 하이 레벨 */

/* UPP FUNCTION TABLE 구조체의 정의 */
typedef struct {
        byte   fnr;         /* FUNCTION NUMBER 레지스터 */
        byte   cmr;         /* 커맨드 레지스터 */
        byte   rasta;       /* 데이타 레지스터 선택 레지스터 A */
        byte   rasrb;       /* 데이타 레지스터 선택 레지스터 B */
        byte   ioara;       /* 클럭 핀 선택 방향 설정 레지스터 */
        byte   ioarb;       /* 트리거 핀 선택 방향 설정 레지스터 */
        byte   ioarc;       /* 펄스 출력 핀 선택 레지스터 */
        byte   ioard;       /* 게이트 입력 선택, 방향 설정 레지스터 */
}upp_func_table;

/* UPP START/STOP 시키는 매크로 */
#define upp_start()  pokeb(UPP_SEG,UR_USCR,UPP_START)
#define upp_stop()   pokeb(UPP_SEG,UR_USCR,UPP_STOP)

/* UPP를 위한 POKE(),PEEK()의 정의 */
/* 인터럽트 사용시에 문제가 있기 때문에 사용하지 않고 함수로 대응한다.
#define   pokeu(o,d)    (pokeb(UPP_SEG,(o),(d)>>8),pokeb(UPP_SEG,(o)+1,
 
(d)&0xff))
#define peeku(o)       (((peekb(UPP_SEG,(o))&0xff)<<8)+              \
(peekb(UPP_SEG,(o)+1)&0xff))
*/
#define pokeub(o,d)  pokeb(UPP_SEG,(o),(d))
#define peekub(o)    (peekb(UPP_SEG,(o))&0xff)

/* 함수 프로토 타입 */
void pokeu(int ofs,int d);
int peeku(int ofs);


#118   디지탈   (k2dig   )
V25 관련 자료 SP.24 #6-1                     03/05 16:54   93 line

제6장 C언어를 ROM화 하기 위한 실험 환경과 TOOL
        CPU BOARD와 개발환경

 +----------+
 | 하드웨어 |
 +----------+
이책에서 예제로 되는 프로그램을  실행시키기 위해서 사진 6-1과 같은 시
판 CPU BOARD를 사용하였다.(사진 6-1) 하드의 사양은 표 6-1에 회로도,핀
번호를 그림 6-2 A,B 그리고 표 6-2에 나타낸다. 이 그림에서 알 수  있는
것과 같이 8086  CPU를 사용한 것과   다르고, 16BIT CPU를 사용하고 있어 
단순한 구성으로 되어 있다.  V25 CPU  는 데이타 버스와 어드레스 버스가 
독립해서 나가고 있고, 외부 데이타 버스의 폭이 8BIT  이다. 클럭 제네레
이터를 기초로 시스템의 구성에 필요한 하드웨어를 내장하고 있는 등의 특
징과 같이  최소 구성의 하드웨어를 구성할때는  상당히 간단하게 만들 수 
있다. 이것은 하드웨어를  설계하는 입장에서 본다면 매우 편리한 것이다. 
CPU의 특징은 7장에 있고, 여기서는 보드에 대해 설명한다.

●메모리 맵
메모리 맵은 그림 6-2 A의 회로 가운데 있다. 롬은 끝의 64Kbyte, 램은 선
두의 64Kbyte로 배치하고 있다.  CPU BOARD 상의 I/O는  V25 내장 I/O포트
와 UPP의  I/O포트로, 이것은  전부 메모리 맵에  할당되어져 있기 때문에 
I/O공간은 64Kbyte 로 사용하고  있다. 8086 CPU의 1Mbyte 라는 퍼스컴 상
에서는  부족하지만, 그다지 큰 용량을 필요로 하지 않는 것에서는 충분하
다. 그러나, 향후 10년  정도 후에는 간단한 시스템에서도 1Mbyte 의 메모
리도 부족하다고 말할 수도 있다.

●V25 CPU 와 주변 IC의 인터페이스
V25 CPU는 86계열이지만, 주변  인터페이스는  같은 8080 CPU를 기초로 한 
것으로써 8086계열과는  별도로 발전한 Z80 계열과는  다소 차이가  있다. 
우선 READ/WRITE  신호가 없고, 대신  68계 CPU에 있는 READ//WRITE신호와 
/MREQ, /IOSTB 신호가 출력되고 있다. STROBE의 폭이 좁은 /MSTB라는 신호
도 제공된다. 이것은 DRAM을 사용할때를 위한 출력이다. 그림 6-4. 두개의 
메모리와 80계 주변 LSI는  READ//WRITE 신호로 제어하게 되어  있다. V25
의 신호에서 메모리, 주변  LSI 인터페이스를 위해서는 /MRD, /MWR 신호를 
만드는 것은 그림 6-5와 같은 로직을 쓰면 된다. 여기서 소개한 CPU BOARD 
에서는 IC를  절약하기  위해서 DECORDER 용 IC로 있는 AC139 를 사용해서 
/MRD, /MWR 신호를 만들어  내고 있다. 어드레스 디코드에는 CMOS  타입의 
AC138,AC139 가 사용된다.   회로도에서는 AC138은 MAX690에서 공급되어지
는 백업 전원에 연결되어 있어 메모리 백업 로직의 일부를 구성하고 있다. 
그림 6-6.MAX690은  전원전압 검출용 IC로  전원이  일정레벨(4.6V)이하로 
떨어지면, 리셋을 L로 하고,  전압이 레벨이상으로 되면 50 mSEC뒤에 리셋
을  H로 한다. 바꾸어  말하면, 50msec 의 리셋 펄스를 출력한다. 또한 전
원전압이 떨어질때에 자동적으로 전원을 백업용 배터리로 저장하는 기능을 
갖고 있다.  여기서 백업으로는 전기2중층 콘덴서가  사용되고  있다. R은 
전기2중층 콘덴서에 충전하기 위한 저항이다.

 +---------------------------------------------+
 | 프로그램 개발에 필요한 하드웨어, 소프트웨어 |
 +---------------------------------------------+
 이번에 프로그램을  보드상에서 실행시키기 위해서는 다음의  하드웨어와 
소프트웨어를 사용하였다.

⑴ PC9801 SERIES 의 퍼스컴과 MS-DOS
⑵ CPU BOARD, 메카트로 트레이닝 보드
⑶ 전원
⑷ 통신 케이블
⑸ TURBO-C, TUROBO-ASSEMBER
⑹ EDITOR
⑺ 통신 소프트웨어
⑻ HEX FILE 생성 소프트웨어 (TOHEX.EXE)이하 순서에 언급해 설명한다.

⑴ MS-DOS 가 사용되어지는 퍼스컴
퍼스컴은 PC-386을 사용하였다. RS-232C포트 이외에 특별한 하드웨어를 사
용하고 있지 않기 때문에 TURBO-C를 사용할 수 있는 PC-9801,PC-286시리즈
의 퍼스컴이면 된다.  노트북이 있으면 편리하다. 그러나 결론적으로 말하
면, IBM-PC COMPATIBLE이면 어느것이든 사용이 가능하다.
⑵ CPU BOARD
CPU BOARD는 V25  CPU와 UPP가 탑재되어진 시판의 SINGLE BOARD   COMPUTER
를 사용하였다. 이 CPU BOARD 에는 MS-DOS상에서 개발된 프로그램을  그대
로 사용할 수  있는 모니터가 탑재되어져 있다.  또한 이 보드의 START-UP 
KIT에는 다음에 설명할  전원, 통신케이블, 유틸리티 소프트웨어가 포함되
어 있다.
⑶ 전원
CPU BOARD 에 전원을 공급하기 위한 것이다.
⑷ 통신 케이블
퍼스컴과 CPU BOARD 를 연결시키는  RS-232C용의 통신 케이블이다. 프로그
램 개발중에 CPU  BOARD로 DOWN LOAD 시키고,  퍼스컴을 DEBUG CONSOLE 로 
사용하기 위해서 필요하다.
⑸ C-COMPILER, ASSEMBLER
TURBO-C V2.0  PRO를 사용하였다.  여기에는 디버거를  포함한 통합환경의 
C-COMPILER와  커맨드라인에서 기동하는  C-COMPILER에  있는  ASSEMBLER와 

DEBUGGER가 포함되어 있다.
⑹ EDITOR
소프트웨어 개발에  사용되어지는 EDITOR는 TEXT FILE  을 편집할 수 있는 
것이면 충분하다.필자는 VZ 에디터를 사용하였다.
⑺ 통신 소프트웨어
퍼스컴에서 CPU  BOARD로 DOWN LOAD하고,  퍼스컴을 DEBUG CONSOLE로 하기 
위한 소프트웨어이다.
⑻ HEX FILE 생성  소프트웨어최종 완성된 프로그램을 ROM에 쓸 수 있도록 
HEX 포맷으로 변환시켜주는 프로그램이다.
⑶,⑷,⑺,⑻은 ⑵번에 소개된 START-UP KIT에 포함된 것을 사용하였다.



#119   디지탈   (k2dig   )
V25 관련 자료 SP.24 #7-1                     03/05 16:55   142 line


제7장
        제어용 CPU V25

 +---------------------------------------------+
 | 조립시스템에 사용되는 CPU에 요구되는 조건   |
 +---------------------------------------------+
 퍼스컴에서는 16비트  CPU탑재기종이 대부분이고, HOBBY ELECTRONICS에서
는  8BIT퍼스컴으로도 충분하였다.  그러나, 이제는  조립용 시스템에서도 
8BIT CPU의 사용이 줄어들었다.
 조립용 시스템에서 요구되는 CPU의 성능은 어떠한 것인가? 용도에 있어서 
요소가 다르지만, 공통점은 다음의 두가지이다.

⑴ 하드웨어를 간단하게 사용할 수 있을것.
 Z80으로 대표되는  8BIT CPU가 CPU조립시스템에서  중요한 발판을 가지고 
있는것은 Z80 CPU를 사용하는 것에 비해  8086을 사용하면, 하드웨어가 크
게 된다는 단점이 있다.
 최소한의 기능을 가진 마이컴 조립 시스템을 구성하는데 있어서 하드웨어
의 단순성은 가장 강력한  무기가 된다. 하드웨어가 간단하다는 것은 신뢰
성의 향상과 코스트의 다운에 연결된다.
 8BIT CPU도 진보하여 최근의 HD64180과 Z280등은 8086에 필적하는 성능이
다. CPU 코아는 단순한 것이지만, 주변 LSI도 칩에 내장되어져 있어, 하드
웨어는 점차적으로 단순하게 되어간다.
 지금은 8086과 Z80 CPU의 가격차도 1000엔 정도밖에 안된다.
 Z80계의 CPU HD64180 으로는  롬, 램, 각 1개씩 있는 최소한의 기능을 가
진 보드를 만들 수 있다. 그렇지만, 16BIT CPU 8086은 그렇게 할 수 없다. 
가장 간단한 CPU보드를 만드려고 생각해도 클럭 제네레이터를 비롯한 주변 
IC를 필요로 한다. 그때문에  CPU기판 전체로 따지면, 결국은 큰 가격차가 
되고 만다.

⑵ 개발환경을 정해서 소프트웨어 개발을 용이하게 할 것.
 다음에 개발환경의 문제가 있다.  8BIT CPU 특히 80계열 CPU는 역사가 있
기때문에,  많은 메이커에서  많은  개발시스템이 발표되었다.  특히 Z80, 
8080의 도스로서 일세를 풍미한 CP/M상에서 실행되는 소프트웨어에는 우수
한 것이 많이 있었다.
 또한 데이터버스폭을 16BIT  로 하게 되면 롬이  최저 2개가 필요하게 되
고, 그러한 기능을 겸비한 롬라이터가 없으면 롬쓰기가 불가능하게 된다.
 ICE 인서킷 에물레이터등의  하드웨어를 가지고 개발하여도, 8BIT용 에서
는 싼 가격으로  사용하기가 쉬운 것이 많이  발매되고 있다. 특히 16 BIT 
CPU로 되면 하드웨어가 복잡하게  되고, ICE등의 개발툴도 단가가 높게 된
다.
 그러나, 조립시스템에 8086계열을  사용하게 되면, MS-DOS의 개발툴을 그
대로  사용가능하다. 개발환경은  Z80의  소프트웨어를 개발할  때와 같이 
CP/M머신을 이용하기도 하지만, MS-DOS상에서 CP/M을 에물레이트하는 환경
을 사용하는 것이 더 좋다.
 개발환경에 관해서는 8BIT CPU는 불리하다. 이렇게 말하는 것은 소프트웨
어는 가장 많이 보급되는  머신을 중심으로 흘러가기 때문이다. 물론 8BIT 
CPU 의 개발환경이  발전하고는 있지만, 세계표준의 IBM PC/AT의 소프트웨
어와 거기에서 이식된 PC98,PC286환경하에서는 열세이다. 그래도 8BIT CPU
가 많이 이용되는 이유중의  하나는 개발환경에 대한 관습이 있다. CP/M환
경에서는 비교적 쉽게  되던 ROM화 기술이, MS-DOS환경하에서는 비교적 어
렵게 된다.  8086 어셈블러는 Z80 어셈블러에  비해서 상당히 어렵게 되어 
있다.
 때문에 조립시스템의  소프트웨어-어셈블러-를 중심으로 하는 프로그래밍
에서는 8086은 훨씬 사용하기가 어렵다. 그때문에 롬화가 불가피한 조립시
스템에서는 8BIT CPU가 강력한 CPU가 된다.
 그러나 이문제는 전술한 것과 같이 MS-DOS프로그램을 그대로 롬화 가능한 
CPU보드를 사용하는 것으로 해결할  수 있다. 6장에서 설명한 보드에는 시
스템을 콤팩트화 할 수  있으므로, MS-DOS 일부의 기능을 에물레이트한 모
니터도 부가적으로 사용하고 있다.
 최근 롬화를 의식해  MS-DOS를 MICROSOFT사에서 개선하였다. 또한 디지탈 
리서치사도 롬화를  고려한 MS-DOS COMPATIBLE  DOS를 발매하였다. 때문에 
본격적으로 MS-DOS가 콤팩트한  보드상에서 사용될 수 있는 환경도 증가되
고 있다고 생각된다.

 +--------------------------------+
 | 조립용 시스템에 적합한 V25CPU |
 +--------------------------------+
 이제까지 설명한 것처럼 8086계는  손쉽게 사용할 수 있는 것이 아니라고 
생각하고 있는 분이 많을텐데, 필자도 그중의 하나였다. 여기서 등장한 것
이 8086 COMPATIBLE  인 V25(uPD70322:일본전기,그림 7-1)!!!! V25는  외부
데이타 버스폭이 8BIT로  Z80과 같이 어드레스버스와 데이타버스가 분리되
어 있다. 또한 인터럽트 콘트롤러, 타이머, 시리얼포트를 포함해서 다양한 
주변회로를 내장하고 있다. Z80을 사용하는 이상으로 하드웨어를 간단하게 
할 수 있다.
 즉, V25를 사용하면 PC9801용의 개발환경을 이용, Z80계의 CPU와 같은 간
단한 하드웨어를 구축할 수 있는 장점이 있다는 것이다.

●V25의 특징
 다음에 V25의 특징에  관해서 설명한다. 조립용 CPU로서의 용도에 기준해
서 설명을 하기로 한다.
 일반적인 CPU의 평가에서는 하드웨어가 복잡하여도 발휘가능한 성능이 높
으면 좋게 평가되지만, 여기서는 조립용 CPU로서의 장점에 주목한다.

⑴ 8086과 소프트웨어 컴패티블이다.
 이것은 아주 좋은 장점이다. 8086의 미래가 어떻든 간에(68000계의 CPU가 
천하를 평정하더라도) 가장 많이 보급하고 있는 퍼스컴에서 사용하고 있는 
CPU와 컴패티블이라는 것은 범용 CPU의 필요조건이다.

⑵ 외부 8BIT 데이타버스로 어드레스버스와 데이타버스가 분리되어 있다.
 조립용 시스템에서 요구되는  CPU의 성능은 8BIT CPU로도 충분하다. 그때
문에 CPU의  성능향상을 위한 여분의  하드웨어를 필요로하는 16BIT CPU는 
환영받지 못한다. 거기에 롬을  쓸때에도 8BIT롬을 두개 쓰는것은 훨씬 시
간이 걸린다. 그러한 점에 있어서도 조립용 시스템으로서는 외부 8BIT데이
타버스의 16BIT CPU가 환영받을 수 있는 것이다.

⑶ 시리얼 포트를 2채널 가지고 있다.
 최근 원칩 CPU의 대부분이 표준 시리얼 포트를 내장하고 있다. 시리얼 포
트의 사용이 일반적으로 되어졌기 때문이다.
 먼저 이번에 소개하는 CPU보드에서는 프로그램의 개발에 적극적으로 시리
얼포트를 사용하고 있기 때문에 시리얼포트를 내장하고 있는 CPU라는 것은 
필요조건이다.
 또한 시리얼포트의 1채널은 I/O모드로 사용할 수가 있다. I/O모드라는 것
은 데이타의 입출력을 시리얼로  행하는 것이다. 현재 일반적인 것은 아니
지만, 데이타전송을 고속으로 행하게 되면 많은 장점을 가지고 있다.

⑷ 24BIT의 I/O포트
 V25는 원칩CPU이기 때문에  I/O포트도 가지고 있다. 그리고 이러한 I/O포
트는 일부를 컴퓨터의 콘트롤 신호와 겸용으로 사용하고 있기때문에, 전부
를 입출력으로서 자유롭게 사용하는 것은 아니다.

⑸ 8BIT COMPARATOR INPUT
 이것은 입력포트의 한  종류이지만, 입력 드레숄드 레벨을 16단계로 설정
가능하게 할 수 있다. 그리고 입력의 응답속도는 일반의 디지탈 입력에 비
해서는 느리다.

⑹ 두개의 16BIT TIMER
 타이머는 제어에 꼭 필요한 것이다. V25는 16BIT TIMER를 두개 가지고 있
다. 그중 하나의 출력은 외부의 신호로서 취급할 수 있도록 되어 있다.

⑺ 시스템 클럭을 절환 가능
 이것은 상당히  새로운 기능이라고 생각한다.  실제의 용도로서 생각한다
면, 클럭을 절환하는 기능이 들어가 있다는 것만으로 '음.. 제어용으로 만
들어진 CPU이군..'라고 감격한 것은 필자만이겠지만.

⑻ 8 SET의 레지스터 뱅크
 V25의 레지스터는 범용  내부램으로서 억세스 가능하고, 레지스터 세트가 
8조 이용되고 있다.  인터럽트 루틴을 기동할때 레지스터 세트를 절환하는 
것으로 인터럽트 응답을 빠르게 할 수 있다.
 레지스터 뱅크 기능면에서  본다면, 시리얼 타임 모니터를 사용하지 않고
서는 CPU의 성능을 발휘불가능하다고 말하는 사람이 있지만, 그런 것을 의
식할 필요는 없다. 풍부한 자원을 무한히 사용하고, 이것을 이용해 하드웨
어를 상대로 고군분투하는 프로그래머의 입장에서는 즐거운 것이다.
 이런 것은 별개의 문제이고,  중요한 것은 풍부한 기능을 잘 사용하여 사
람의 손을 적게 쓸 수 있도록 하는 것이 요구되고 있다.

⑼ 내부 인터럽트 요인에 의한 인터럽트 콘트롤러
 8086계 CPU에서는 인터럽트  콘트롤러를 외부에 부착하지 않으면, 인터럽
트를 처리할 수  없지만, V25에서는 내부에 인터럽트 콘트롤러를 내장하고 
있어 내부의 I/O에 관한 인터럽트는 물론, 인터럽트 콘트롤러 없이 외부의 
인터럽트에도 대응 가능하도록 되어 있다.



#120   디지탈   (k2dig   )
V25 관련 자료 SP.24 #7-2                     03/05 16:56   233 line

------------+
 | V25의 아키텍처 |
 +----------------+
 전체의 블록도를  그림 7-2에 나타낸다.  연산명령실행을 담당하는 CPU부
분, 16KBYTE 내장롬, 주변 하드웨어군들을 볼 수 있다.
 CPU는 ALU,ABM,DCL 등의 UNIT로 구성되고, 내부 16BIT의 아키텍처를 채용
하고 있다. 외부 버스 사이클을 기동하는 DCL은 명령실행과 독립적으로 파
이프라인 동작을 할수가 있다. 덧붙여 말한다면, V25의 명령실행 클럭수를 
고려할 때,  메모리로의 데이타 전송명령등 외부  메모리 억세스를 행하는 
일부의 명령에서 WAIT STATE를 염려할 필요는 없다. 참고로 일부의 명령실
행 클럭수를 표 7-1에 나타낸다.
 또한 V30과 같이 6BYTE의  PREFETCH QUEUE 를 가지고 있고, OPCODE  FETCH 

를 가지고 있으며,  동작중에 있는 CPU명령실행중단시간을 감소시킴으로서 
CPU의 실행효율을 증가시키고  있다. 이 PREFETCH QUEUE는 QUEUE내부의 코
드가 1BYTE이하로 되면, 외부로의 READ/WRITE에 우선해서 PREFETCH 동작을 
행한다.(강제 PREFETCH) 명령실행  클럭수에는 강제 PREFETCH에 걸리는 클
럭을 포함하고 있지 않기  때문에, 명령실행 클럭수를 계산할 경우에는 주
의가 필요하다.
 먼저 CPU는 8BANK의 레지스터 뱅크를 가지고 있고, 레지스터 뱅크는 내장 
램에 메모리 매핑되어 있기 때문에, 레지스터 조작 명령뿐만 아니라, 메모
리 조작명령으로도 읽고 쓰기가 가능하다. 따라서 복수의 레지스터 뱅크를 
사용할 경우등에 있어서, 메모리 조작명령으로 직접 범용 레지스터 포인터
군(CONTEXT)의 초기화, 갱신을 행할 수 있다. 물론 내장 램은 범용 데이타 
영역으로서 사용할 수도 있다.
 한편, CPU는 많은 마이컴에서  채용하고 있는 마이크로 프로그램 제어 방
식을 사용하고 있다. 최근에는  V33과 같은 WIRED LOGIC 제어 방식으로 명
령실행에 요하는 시간을  대폭 단축한 마이컴도 있지만, V25에서는 마이크
로 프로그램  제어방식을 채용하는 것으로  매크로 서비스등의 부가기능을 
전용 하드웨어를 가지고 있지 않은채 제공하고 있다.
 16KBYTE의 내장 롬은 RESET시에 /EA단자를 HIGH레벨로 설정하면 유효하게 
된다. 내장 롬에서의 OPCODE FETCH는 외부로의 READ/WRITE동작과는 독립적
으로 내부의  전용버스를 이용해서 행해질 뿐만  아니라, 분기되는 경우를 
제외하고 1BYTE/CLOCK  의 고속 FETCH를  행하기 때문에, 명령실행 효율이 
높고, OS의 커넬부분, 모니터 프로그램등의 OPCODE 대체에 유효하다.
 이밖에 주변  하드웨어로써 클럭  제네레이터를 포함,  인터럽트 콘트롤, 
BAUD-RATE 제네레이터  내장의 시리얼 콘트롤러,  16BIT의 인터벌 타이머, 
20BIT의 PRE-RUNNING  동작을 하는 타임 베이스  카운터 등을 내장하고 있
다.

●단자기능
 단자기능을 표 7-2에 나타낸다. 그리고 패키지는 84PIN PLCC(그림 7-3)와 
94PIN QFP를 이용하고 있다.






 +-----------+
 | 메모리 맵 |
 +-----------+
 V25의 메모리  맵을 그림 7-4에 나타낸다.  1MBYTE의 메모리 공간의 하위 
1KBYTE는 V30과 같이 벡터  영역으로 되어 있고, 일부에 관해서는 내장 주
변 하드웨어에서의  인터럽트 용으로 예약되어 있다.  내장 롬은 최상위에 
할당되어 있고, 이외에 내장 램과 내장 주변 하드웨어(특수 레지스터)등이 
각각 256BYTE의 영역으로 할당되어 있다.
 /EA단자를 LOW 레벨로 고정하면, 내장 롬 없는 모드로 동작하고, 그 영역
은 외부에 대해서 억세스를  행한다. 내장 주변 하드웨어는 메모리 공간에 
매핑되어 있기때문에, C언어로 직접 핸들링 할 수 있다.
 내장 램과 특수기능  레지스터는 IDB 레지스터로 상위 8BIT가 지정되어진 
어드레스로 할당되어  있고, 재배치 가능하다.  <<<여기서 IDB 레지스터는 
FFFFFh번지(고정)와   FFFh번지(  는 IDB 레지스터 자신의 값)로 이중으로 
매핑되어 있기 때문에  어떠한 것을 READ/WRITE로써 구축할 수는 없다.>>> 
특수기능 레지스터를 표 7-3에 나타낸다.
 내장 램은 레지스터 뱅크, 매크로 서비스채널(매크로 서비스를 위한 파라
메터 영역),  DMA 서비스 채널(DMA를 위한  파라메터 영역) 등을 할당하고 
있지만, 이러한 용도로 사용하지  않는 영역에 관해서는 범용 램으로써 사
용할 수 있다.
 내장 램과  특수기능 레지스터는 내장 롬과  중복되어져 있지만, 이 경우 
OPCODE FETCH는 내장 롬, 데이타의 READ/WRITE는 내장 램과 특수기능 레지
스터를 우선적으로 억세스한다.
 내장 램에  관해서는 소프트웨어로 메모리로서의 억세스를  금지할 수 있
다. 메모리 억세스를 취급하는  명령에서는 내장 램의 억세스를 금지한 쪽
의 명령실행에 요하는  클럭수가 작기때문에(표 7-1) 소용량의 데이타영역
으로의 이용과 매크로  서비스 채널등의 데이타 초기화 이외에서는 억세스
를 금지해 두면 좋다.

 +---------------+
 | 레지스터 세트 |
 +---------------+
 CPU는 V30과  기본적으로 동일한 범용 레지스터  세트를 8세트 가지고 있
고, 이것을 내장 램에  매모리 매핑하고 있다. 따라서 레지스터 조작 명령
뿐 아니라, 메모리 조작 명령으로도 억세스할 수 있다.(그림 7-4) 8세트의 
레지스터 세트는 레지스터  뱅크로서 하드웨어 인터럽트 전용 명령으로 절
환해서 사용할 수 있다. 리세트시에는 레지스터 뱅크 7번이 선택되기 때문
에, 통상 메인의 처리는 뱅크 7로 처리한다.
 레지스터 뱅크를 채용한 CPU는  다른 것도 있지만,대부분 멀티태스크 제
어에 있는 CONTEXT의  일괄대피를 목적으로 하고 있고, 하드웨어 인터럽트
에 있어서 자동적으로 절환을 행하는 것은 새롭다고 생각할 수 있다. 이것
도 제어용을 의식한 기능이라고 할 수 있다.
 CPU의 플래그를 그림 7-5에 나타낸다. /IBRK,RB0-RB2,F0-F1의 6개의  플래
그가 V30에 비해서 추가되어 있다.

▶/IBRK
 IN/OUT 명령을  TRAP하고, 내장 주변  하드웨어같은 에물레이션을 행하는 
목적을 위해 추가되어 있다.

▶RB0-RB2
 사용중인 레지스터 뱅크 번호를 가지고 있다.

▶F0-F1
 유저 프로그램에서자유로이 정의 가능한 플래그이다. 특수기능 레지스터
의 세스  할 수도 있다.(그림 7-6) 멀티 태스크 제어
시의 태스크 정보의 보관등에도 이용할 수 있다.

 +----------------------------------+
 | 외부버스 사이클과 메모리 접속 예 |
 +----------------------------------+
 V25의 외부버스는 20BIT어드레스  버스와 8BIT데이타 버스를 완전히 분리
하고 있고, 외부 부착용 어드레스 래치를 필요로 하지 않는다.
 외부 버스의 제어신호로서는 READ//WRITE,/MREQ,/IOSTB,/MSTB가 있다. 외
부버스 타이밍을 그림 7-7에 나타낸다.
 READ//WRITE신호는 메모리,I/O에 대해서  공통으로 사용할 수 있다. 각각 
/MREQ,/IOSTB와 논리합을 하여 메모리,I/O에 대한 READ//WRITE신호를 발생
한다.
 /MSTB는 대부분의  경우 사용할 필요는  없지만, DRAM과의 접속에 있어서 
/CAS 타이밍으로  사용할 경우가 있다.  스펙는 
스피드에서의 NON-WAIT동작등에서는 데이타의 셋업 타이밍이 /MSTB 출력보
다도 앞에 규정되어 있기 때문에 유효한 신호라고 말할 수는 없다.
 SRAM과의 인터페이스 예를 그림 7-8에 나타낸다. PROM,외부 I/O 인터페이
스도 기본적으로 같다.
 참고로 READ//WRITE사이클의 타이밍  스펙을 그림 7-9에 나타낸다. 이 버
스 사이클은 /MREQ 혹은  /IOSTB의 하강으로 버스 사이클이 기동되는 것을 
알 수 있고, 전체의 타이밍은 이것을 중심으로 동작된다.

 +-------------------+
 | 하드웨어 인터럽트 |
 +-------------------+
 V25의 가장 특징적인 기능이 인터럽트 기능이라고 말할 수 있다. 그 하드
웨어 인터럽트 요인을 표 7-4에 나타낸다.
 NMI,INT를 제외한 하드웨어  인터럽트는 프로그래머블한 우선순위에 따라
서 순서가 정해진다. 우선순위(8레벨)는 소프트웨어에 있어서몇개의 그룹
단위로 설정된다.  다중처리제어에 있어서  서비스중인 인터럽트 처리보다 
우선순위가 낮은 인터럽트 요구는 서비스중인 인터럽트가 전부 처리되어질
때까지 보류되지만, 그 이외의  경우에는 인터럽트 처리 루틴 중에서 EI상
태(인터럽트 허가)를 설정하는  것으로 NESTING처리되어진다. 이러한 인터
럽트 처리방법으로서는 V30과 같은 벡터 방식 외에 레지스터 뱅크절환, 매
크로 서비스의 세종류를 선택할 수 있다.
 각 인터럽트의  처리방법, 우선순위, MASK  지정은 각 인터럽트 요인별로 
제공되는 인터럽트요구  제어레지스터로서 지정한다. 인터럽트요구 제어레
지스터의 구성을 그림 7-10에 나타낸다.
 인터럽트요구제어레지스터 BIT 7은 인터럽트 요구를 나타내고, WRITE동작
도 가능하게 되어  있기 때문에 소프트웨어로 인터럽트요구를 SET/RESET할 
수 있다. BIT  6은 MASK 지정 BIT이고,  개별적으로 인터럽트를 금지할 수 
있다.
 또한 BIT 5,4는 각각  인터럽트 처리 방법을 지정하는 필드이다. BIT 2-0
은 우선순위를 지정하는  필드이지만, 이 우선순위는 하나의 인터럽트그룹
에 한개씩 할당되어 있고, INTTU0, INTD0, INTP0, INTSER0,또한  INTSER1의 

인터럽트요구제어레지스터만이 유효하게 된다.
 리셋직후는 전체의 우선순위는 최하인 7로 되고, 인터럽트요구제어레지스
터의 BIT 6에 따라서 MASK되어진다.

●레지스터뱅크 절환
 V25에서는 인터럽트를 개시할때  레지스터뱅크를 자동적으로 절환하는 것
으로 사용중인  레지스터세트를 스택에 대피하지 않고,  세이브할 수가 있
다. 이처럼 종래 유저프로그램에서 행했던 범용 레지스터군의 대피,복귀처
리는 불필요하게 되고, 인터럽트 처리시간의 단축화, CPU의 OVERHEAD의 경
감, 소프트웨어 코딩의 효율화에 기여한다.
 레지스터뱅크 절환에 있는  인터럽트처리 시퀀스를 그림7-11에 나타낸다. 
각 레지스터뱅크에는 범용레지스터,  세그먼트 레지스터외에 PC 대피영역, 
PSW 대피영역과  벡터 PC영역이 확보되어  있다. 인터럽트 발생에서 CPU의 
PC가 절환된후 레지스터뱅크의  PC대피영역에 세이브되고, 대신에 벡터 PC
의 값이 PC에 로드된다. 동시에 절환하기 앞서 플래그(PSW)류를 PSW대피영
역에 세이브한다.
 예로써 각부 인터럽트 INTP1을  레지스터뱅크 3에 사용하는 방법을 설명한
다.
 우선 메인루틴에 있어 인터럽트처리루틴의선두어드레스를 레지스터 뱅크 
3의 PS(  E6Ch;  는 IDB레지스터의 값),벡터 PC(  E62h)에 세트한다. 이때 
인터럽트 처리의 내용에 대응하는 필요한 범용레지스터,세그먼트 레지스터
(특히 SS,SP에 주의)도 초기 설정해 둔다.
 다음에 INTP0의  요구제어레지스터 EXIC0의 하위 3BIT(PR2-PR0)에 레지스
터뱅크 번지 3을  세트한다.레지스터뱅크 번호는 INTP1과 같은 인터럽트그
룹의  INTP0(그룹  내에서  최고  우선순위)의  인터럽트요구제어레지스터 
EXIC0(그림  7-10)에 있어서  지정되기  때문에 주의가  필요하다. 끝으로 
INTP1의 인터럽트요구제어레지스터 EXIC1에 17h(00010111)를 쓰고, 레지스
터 뱅크 절환을 지정해준다. 이상의 처리흐름을 그림 7-12에 나타낸다.

●매크로 서비스
 매크로 서비스는 본래  유저프로그램에서 인터럽트 처리를 하던 전형적인 
것을 CPU가 처리하는 것을 말한다.
 매크로 서비스에서는 인터럽터 처리때의 범용레지스터군의 대피,복귀동작
이 불필요하기 때문에 레지스터뱅크 절환과 같이 CPU를 효율적으로 사용할 
수 있다. V25에서는 인터럽트요구로 처리되는 임의의 특수기능 레지스터와 
메모리 사이의, 그리고 쌍방향의데이타 전송을 자동으로 실행할 수 있다. 
매크로 서비스의 개념도를 그림 7-13에 나타낸다.
 구체적으로는 1회의 인터럽트  요구에 대해서 메모리와 내장 주변 하드웨
어 사이에 1회의 데이타전송을  행하기 때문에, 1회의 전송으로 메모리 어
드레스를 자동적으로  증가시킨다. 그리고, 일정횟수의  전송의 전송을 하
면, 벡터, 혹은 레지스터뱅크 절환처럼 인터럽트를 발생하고, 그 인터럽트 
처리에서 다시 한번 매크로 서비스를 기동시킨다.
 게다가 시리얼의 송신동작에  있어서 송신완료 인터럽트로써 메모리 버퍼
상의 다음 송신 데이타를 송신버퍼에 세트하는 처리는 매크로 서비스로 처
리할 수 있다.(수신동작도 같다) 또한 타이머 인터럽트에서 일정주기로 포
트의 출력 데이타를 변화시키는 것에도 이용할 수 있다.
 V25의 경우  DMA도 내장하고 있지만, 이경우  내장 주변 하드웨어를 위한 
전용화되어진 DMA라고 생각할 수 있다.
 벡터 방식과 레지스터뱅크 절환, 매크로 서비스에서의 CPU OVERHEAD의 비
교를 그림 7-14에  나타낸다. 레지스터뱅크 절환과 매크로 서비스는 CPU를 
효율적으로 사용하기 위한 수단이라고 말할 수 있다.
 매크로 서비스의동작상태를 설정하기 위한 레지스터로서 각 인터럽트 요
인별로 이용되는 매크로서비스 제어레지스터의 구성을 그림 7-15에 나타낸
다. 비트 7-6은 동작 모드, 비트 4는 데이타의 전송방향, 비트 2-0은 매크
로 서비스시에 참조하는  파라메터 영역(매크로 서비스 채널)을 지정한다. 
캐릭터 서치 모드를 지정하면 전송 데이타를 어느 임의 캐릭터와 일치할때 
매크로 서비스를 중단하고, 인터럽트를 발생시킬 수가 있다.
 매크로 서비스 채널은 내장  램의 레지스터뱅크 1에 대해서 다중으로 8채
널을 할당하고 있다.(그림 7-4)  MSS, MSP에 전송대상으로 되는 메모리 어
드레스, FSRP에 전송대상으로  되는 특수기능 레지스터의 어드레스, MSC에 
전송횟수를 설정한다.
 캐릭터 서치모드를  사용할 경우는 SCHR에  검출할 전송 캐릭터를 설정한
다. 8BIT전송의 경우 1회의 전송에 MSP는 +1,MSC는 -1되어진다.
 매크로 서비스에서 CPU가 범용레지스터군을 억세스 하는것은 아니기 때문
에 DI상태에서도 매크로 서비스는 실행된다.
 매크로 서비스를 사용한 시리얼의 송수신 동작의 예를 후술한다.

 +---------------------+
 | 소프트웨어 인터럽트 |
 +---------------------+
 V25의 소프트웨어인터럽트의 요인을 표 7-5에 나타낸다.

▶입출력명령 TRAP
 IBRK FLAG가  '0'일때, IN/OUT명령을 실행하도록  하면 TRAP이 발생한다. 
소프트웨어의 이식을 행하는 경우에 유효한 기능이다.

▶FPO의 명령 TRAP
 V25는 8086과 BUS구성이 다르기 때문에 8087CO-PROCESSER는 접속 불가능하
다.
 V25에서는  8087용  명령을 실행하도록  하면  TRAP이  발생하기 때문에, 
STACK에 대피되어진 PC의 값을 사용해서 직접OP-CODE을 읽어내고, 그 동작
을 V25자신이 에뮬레이터 할수 있다.



#121   디지탈   (k2dig   )
V25 관련 자료 SP.24 #7-3                     03/05 16:57   284 line



+------------------+
| CONTROL REGISTER |
+------------------+
●기본적인 동작을 CONBTROL하는 레지스터
▶PRC 레지스터
 PRC 레지스터의 구성을 그림 7-16에 나타낸다.
 PRC레지스터에서는 원 발진에 대한 시스템 클록의 분주비를 지정한다. 리
셋트 직후는 당연 한것이지만  가장 늦은 원발진의 1/8의 주파수로 동작을 
개시하기 때문에, 통상은 처음에 가장빠른 1/2의 분주비로 절환 해서 사용
한다. 절환은 PRC 레지스터에 대한 쓰기를 행하는 것이지만, 그 때에 절환 
타이밍을 의식할 필요는 없다.
 또한, PRC레지스터의RAMEN  플래그는 내장 RAM을 메모리로서 ACCESS할것
인지의 여부를 결정한다.   DEFAULT는 ACCESS허가의 지정으로 되어있지만, 
전술한 것  처럼 ACCESS의 필요가 있는  경우이외에는 금지하고 있는 편이 
좋다.

▶WTC 레지스터
 V25는 외부  버스 사이클에 대한  WAIT를 자동설정할수가 있다. 웨이트의 
삽입수는 0,1,2 (2+READY단자제어분)등을 선택할수가 있고, WTC레지스터에 
있는 소프트웨어로 지정가능하다.
 WTC 레지스터의 구성을 그림 7-17에 나타낸다. 지정하는 영역은 메모리가 
128K BYTE단위로 7화면,  I/O가 64K BYTE단위로 1화면이다. 이제, READY단
자를  유효하게  하기위해서는   WTC레지스터에  "11"을  설정하는  것과, 
P17/READY단자를  CONTROL MODE로  설정할  필요가 있다.  이  경우,  필히 

2WAIT이상이  들어가게 된다.  RESET직후는  전부 "11"로  되지만, 동시에 
READY단자가 무효로 되기 때문에, 2WAIT로  된다.

▶RFM 레지스터
 DRAM, 류이 SRAM에 대한 REFRESH CYCLE의 주기, WAIT수, 금지상태를  설정
하는 래지스터이다. 그림 7-18에   RFM레지스터의 구성을 나타낸다.  리셋
트직후는 2 WAIT의 REFRESH CYCLE이 16 CLOCK주기로 들어가도록 설정 되어
지기 때문에, 시스템의 메모리 구성에 대응해서 초기 설정을 할 필요가 있
다.

▶STBC레지스터
 STBC레지스터의 구성을 그림 7-19에 나타낸다. 리셋트에 있는 STOP상태에
서 복귀와 POWER-ON 리셋트를 구별할수가 있다.

●입출력단자를 CONTROL하는 레지스터
 범용 PORT의  대부분은 CONTROL단자와  겸용단자로 되어있고, 개별적으로 
선택할수가 있게  되어있다.기능의 선택은  PORT에 사용되는  두개의 8BIT 
REGISTER PMCn,PMn(n=0-2)으로서 행해진다. 이러한 겸용단자는 리셋트시에 
범용입력 포트( 하이 임피이던스 상태)로 되기 때문에, 시스템에 대응해서 
초기설정을 할 필요가 있다.

▶PORT 0
 P00-P07의 동작은 PMC0,PM0 레지스터에 있어서 지정된다.(표 7-6). PM0레
지스터의 각 BIT의  지정으로, 1단자와 범용입력포트 또는 범용출력포트로
써 설정가능하다.  P07에 관해서는, PMC0= 80H로 하는 것으로 시스템 클록
출력으로서 사용할수  있다. 리셋트시에는 시스템 클록은  출력 되지 않기 
때문에, 주의가 필요하다.

▶포트1
 포트1의 동작을 표7-7에 나타낸다.
 P10 - P17에서 P10 - P13은 외부 인터럽트단자로, 단자레벨을CPU에서 읽
어 낼수가 있지만, 기본적으로는 범용 포트로서 사용할수는 없다.
 특히, P10은 NMI이기 때문에 엣지를 입력하면 무조건적으로 인터럽트를 발
생한다.
 여기서, P11 - P13을  범용입력으로서 사용하기 위해서는, INTP0 - INTP2
을 마스크할  필요가 있다.  또한, 이러한  외부 인터럽트는 INTM레지스터 
(그림 7-20)에 있어서 유효 엣지의 방향을 선택가능하다.
 P14 - P17은 범용 입출력으로서 사용할수있다.
 P13, P14는 71059(8259A)상당의  외부인터럽트 콘트롤러를 외부에 부착해
서, 인터럽트 소스를  확장할경우, 인터페이스용단자로서 사용한다. 이 때 
PMC1레지스터의 비트3,4는 각각, "1"을 설정한다. /INTAK을 사용하지 않고 
INT만을 사용하고, 데이타  버스를 PULL UP해두고 벡터255로서 INT를 사용
해서, 확장없이 외부5개의  인터럽트를 기다릴 수가 있다. P14는 입력포트
를 지정한 경우, POLL 명령의 SAMPLING단자로서 기능한다.
 이 외에, P15을 타이머  0의 출력, P16을 시리얼 클록의 출력(비동기통신
의 경우는 출력되지 않고)으로서 사용된다.
 P17은  READY단자로  되지만,  리셋트시는  범용입력으로  있고, READY는 
ACTIVE(WAIT을 삽입하지 않고)상태로 있다.

▶포트2
 포트2의 동작을 표7-8에 나타낸다. 어느것도 PMC2, PM2레지스터로서 범용 
입력,범용출력, CONTROL기능의  한가지를 선택할수가  있다. P20  - P22가 
DMA CHANNEL0용, P23  - P25가 DMA채널1용의 제어단자로서 할당되고 있다. 
또한, P26,P27은 외부의  버스 마스크에있는 버스HOLD를 위한 단자로 되어
있다.

▶포트 T (PT0 - PT7)
 포트 T는 소프트웨어로 비교전압을 16단계로 변화시킬수 있는 콤퍼레이터 
입력이다. 비교전압은 PMT 레지스터에서 그림 7-21과 같이 결정한다.
 간단한 아날로그입력의  전압계측외에, 시리얼로  DIP SWITCH상태의 처리
등, 의외로 폭넓게 사용된다.

 +-------------+
 | 타이머 기능 |
 +-------------+
 타이머로서 2개의  16BIT 타이머와 1개의  20BIT PRE RUNNING  TIMER(TIME 

BASE COUNTER)을 갖고있다.
 16BIT TIMER는  1채널에 각 2개의 16비트레지스터(TMn,MDn:n=0,1)로 구성
되고, 인터벌동작의  경우에는 TMn의  값을 일정주기로  카운트 다운하고, 
TMn=0로 되면 타이밍에서 인터럽트요구를 발생하는 것과 동시에 MDn을 TMn
에 재로드한다. 타이머 0에  관해서는, TM0, MD0을 각각 독립의 원 쇼트타
이머로서 사용할수  있는 외에,  TM0 =  0의 타이밍으로  반전하는 펄스를 
TOUT단자에 출력할 수가 있다.
 16 비트 타이머의 구성을 그림 7-22에 나타낸다.
 2개의 16 BIT TIMER는 각각 TMC0, TMC1레지스터로서 그 동작을 제어한다. 
TMC0, TMC1레지스터의 구성을 그림 7-23(A),(B)에 나타낸다.
 비트 6에서 카운터 클록을 선택하고, 비트7로 동작의 개시/정지의 제어를 
한다. TMC0레지스터에서는  비트 4,5로  원쇼트동작시의 동작제어를, 비트
2,3에서 TOUT단자로의 타이머 출력지정, 비트0,1로 모드의 지정을 행한다.
 타임 베이스 카운터는 비교적 긴 일정주기의 타이머 인터럽트 전용의 타이
머이다.
 인터럽트의 인터벌은 PRC레지스터로서 선택한다. (그림 7-16)

 +--------------------+
 | 시리얼 인터페이스  |
 +--------------------+
 V25는 시리얼포트를 2채널 갖고있다. 현재에서는 시리얼포트를 2채널이상 
가진 ONE CHIP 등이 일반적으로 되었지만, 2-3 년전에는 진기한 것이었다.
 채널1은 조보동기통신을 행하는  비동기모드 전용이지만, 채널0은 비동기 
모드와 클록동기의 I/O인터페이스 모드를 선택할수가 있다.
 보오레이트 제네레이터는 각 체널에 이용되고, 시스템클록을 분주한 클록
을 일정회수분 카운트하는  것으로, 임의의 보오레이트를 발생한다. 이 때
의 카운트 클록의 주파수(분주비)는 SCC0, SCC1레지스터에서 지정한다.(그
림 7-24) 또한,  카운터값은 BRG0,BRG1레지스터로 지정한다. 보오레이트와 
SCCn,BRGn(n=0,1)레지스터의 설정치의 관계는 이하의 식으로 구해진다.

 B.G = 106   fCLK/2m+1
 B : 전송 보오 레이트[bps]
 G : BRGn레지스터의 설정치( 2   G   255 )
 fCLK : 시스템 클록 주파수[MHz]
 m : SCCn레지스터의 설정치( 0   m   8)

 여기서, 비동기모드에 있어서 수신단자의 스타트 비트검출을 위한 샘플링
은 보오레이트 제네레이트의  카운트 클럭으로 행해지기 때문에, SCCn레지
스터의 값은 가능한한 작게  설정할 필요가 있다. 여기서 통상 사용되어지
는 4800bps와 9600bps에있어서는, 8251의  64보다도 정도가 높은 조보동기
통신을 행할수 있다.
 각 채널은 각각 송신과 수신의 하드웨어를 독립적으로 갖고 있고, 전 2중
의 송수신이 가능하다. 송신측은 송신용 시프트레지스터,송신버퍼의 2단계
로 구성되어지고, CPU에서 송신버퍼에 저장되었던 데이타는 송신용 시프트 
레지스터에 셋트되어져, 최하위 비트부터 1 비트씩 TxDn단자로 송출되어진
다.
 또한, 수신측도 수신용 시프트 레지스터, 수신버퍼의 2단구성으로 되어있
고, 수신용 시프트레지스터에 1 캐렉터 분의 데이타를 수신하면 수신 버퍼
에 그 데이타를 집어 넣는다.
 동작상태는 SCM0,SCM1레지스터에서 각 채널을 지정한다. SCM0,SCM1레지스
터의 구성을 그림 7-25에  나타낸다. SCM0는 동작모드에 있어서 각 비트의 
의미가 다르다.  비동기모드에서는 조보동기를위한 통신프로토콜과 송수신
의 허가제어를 행하고, I/O인터페이스모드는 송수신의 허가제어외에, 클럭
의 제어를 행한다.
 송수신 데이타의 주고받는  것은 송신완료,수신완료의 인터럽트와 핸드세
이크로 하는 형태를  갖는다. 인터럽트에 있어서 처리하는, 인터럽트를 마
스크해서 요구 플래그를 소프트웨어로 폴링등의 방법으로 처리한다.
 송신완료 인터럽트의 요구는 송신허가상태로 송신버퍼가 비어있을때 발생
한다. 보다 자세히  설명을 한다면, 송신허가상태로 있을때에  송신버퍼에 
셋트되어진 데이타를  시프트레지스터에 전송하고, 송신버퍼가 비어있을때
에 발생한다.
 또한 송신버퍼가  비어있는 상태에서 송신허가로  된 경우에도 발생한다. 
물론, 소프트웨어로서도 셋트할수도 있다.
 또한, 시리얼 수신에러를  검출하면, 각채널의 SCE0,SCE1레지스터중의 에
러 플래그가 상태를 나타냄과 동시에 인터럽트를 발생시킨다. SCE0,SCE1레
지스터의 구성을 그림7-26에 나탄낸다.
 이 에러플래그는 수신동작이  정상으로 행해질 때까지 변하지 않는다. 비
트7은 수신단자를 직접  모니터하기 위한 플래그이다. 회선 플래그등의 검
출에 사용할수 있다.

●매크로 서비스에 있는 시리얼동작
 여기서, 시리얼  채널0의 송신동작을 송신완료인터럽트로서 기동되어지는 
매크로서비스(매크로서비스 채널은 2를  사용)에 의해서 처리되기 위한 순
서에 관해서 설명을 한다.
 메모리상의 버퍼영역에  연속되는 송신데이타를  이용해서, 매크로서비스 
채널2의 MSS(  E16 번지 :   는 IDB의 값)에 메모리버퍼의 선두어드레스의 
세그먼트값, MSP(  E14번지)에 동일한 오프셋값, MSC(  E10번지)에 버퍼의 
사이즈를 셋트한다.  또한, SFRP(  E11번지)에  특수 기능레지스터로 있는 
송신버퍼 레지스터0의 어드레스의 하위 8 비트를 설정한다.
 다음에 시리얼송신  인터럽트를 위한  매크로 서비스제어레지스터로 있는 
STM0 레지스터에 02H( NORMAL MODE, 8 BIT 전송, 메모리  ->특수기능레지스
터)를 쓴다. (레지스터의 구성에 관해서는 그림 7-14을 참조)
 여기에 인터럽트요구제어레지스터 STIC0에 바이너리로 '001 0   '로 쓰는
것으로 송신완료 인터럽트를  매크로서비스에 설정한다. 비트 4에는 MSC = 
0으로 발생하는  매크로 서비스 완료의 인터럽트  처리방법을 지정하고 있
다. 당연하지만 그 때문에 처리 루틴은 풍부하게 이용할 수있다. 하위 3비
트는 우선순위지정이다.
 끝으로 SCM0레지스터의 비트 7을 '0'부터 '1'로 바꾸어 주는 것으로 송신
허가상태로 하고,  인터럽트(매크로서비스)요구를 발생시켜, 송신스타트를 
<<<새신>>>한다.
 매크로서비스완료의 인터럽트 처리루틴으로 매크로서비스 채널의 STIC0레
지스터를 재설정하는 것으로, 이 동작을 연속해서 행 할수가 있다.
 이상의 처리 FLOW를 그림 7-27에 나타낸다. 수신의 경우도 같은 방법으로 
행하면 된다.







 +---------+
 | DMA기능 |
 +---------+
 외부 I/O와 메모리와의  사이에 비동기의 데이타 전송을 행하는 방법으로
서, DMA기능을  2채널 준비하고 있다.  DMA라는 것은, CPU의 명령실행과는 
독립적으로 외부 버스를 동작시켜서, 데이타의 전송을 행하는 것이다. V25
의 DMA는 메모리와 메모리상의  데이타 전송도 지원하고 있기 때문에 대량
의 데이타를 다루는 시스템에서는 유용하다.
 그리고, V25의 DMA는  CPU에 있어서 제어되고 있기 때문에, 전송레이트는 
약 0.6M Byte/sec(8MHz 동작)정도이고, 그 이상으로 크게할 수는 없다. 이 
이상의 고속으로 데이타를  전송하기 위해서는, V25+라는 전용의 DMA 콘트
롤러를 탑재한 것을 사용할 필요가 있다.(후술)
 전송대상의 메모리 어드레스와  전송회수는 내장 RAM상의 DMA서비스 채널
로 설정한다.   (DMA서비스 채널의  구성에 관해서는 그림7-4을 참조한다. 
이 때, 어드레스의 생성은  그림 7-28처럼, 세그먼트의 값의 곱(4 비트 시
프트)에서 결정되어진다.)
 이제, 메모리와 I/O와의 DMA에 있어서, 전송대상으로 되는 I/O(어드레스)
는 /DMAAK신호로서 선택한다.
 이 외에, DMA의  동작을 지정하기 위해서는 레지스터로서 DMAM0,DMAM1 레
지스터와 DMAC0,DMAC1 레지스터가  있다. DMAM0, DMAM1 레지스터의 구성을 
그림 7-29에, DMAC0, DMAC1레지스터를 그림 7-30에 나타낸다.
 메모리와 I/O와의 전송동작으로서는,  DMARQ단자가 액티브인 사이에 전송
을 연속으로 행하는  DEMAND RELEASE동작과, DMARQ단자의 1회의 유효 엣지
에 대해서 1회 전송을 행하는 1전송동작의 2종류가 있다.
 또한, 메모리와 메모리사이의  전송동작으로서 설정회수분의 전송을 연속
으로서 행하는 FAST동작, 1 명령실행과 1DMA를 교대로 행하는 SINGLE STEP
동작이  있다.  FAST동작, SINGLE  STEP동작은  DMARQ단자의  엣지 입력을 
DMAM0, DMAM1레지스터의 비트 2,3을 셋트하는 것으로 기동한다.

 +---------------------+
 | V30에 대한 추가명령 |
 +---------------------+
 V25는 8086의 명령에 더해서 V30의 오리지널 명령외에 8종류의 명령을 추
가하고 있다. 이러한 것은  어느것도 매크로 정의하는 것으로 종래의 86계 
어셈블러, 콤파일러에서도 기술할수 있기 때문에, 용이하게 개발환경에 이
용할수 있다. 추가명령을 MASM상에서 매크로로 기술한것을 리스트7-1에 나
타낸다.

▶FINT
 8259A에 대한 FI COMMAND에 상당한다. V25에서는 인터럽트 콘트롤러를 내
장하고 있기 때문에, 이 인터럽트 콘트롤러에 대해서 인터럽트 처리완료의 
종료를 지시하기 위한 전용명령으로서 이 명령을 이용하고 있다. 인터럽트 
콘트롤러의 다중처리는  이 명령으로서  제어되기 때문에, 다중처리제어를 
하는 인터럽트에 대해서는,  필히 RETI(IRET)명령의 직전에서 실행할 필요
가 있다.


▶RETRBI
 레지스터뱅크 절환에 의한  인터럽트 처리루틴으로의 복귀명령(IRET 명령
에 상당)이다. BRKCS명령에의한 레지스터 뱅크 절환 시에도 사용한다.

▶STOP
 원발진을 정지시키는 것으로, 소비전류를 억제한다. 발진자를 직접(?) 부
착한경우에 사용할수 있다.

▶BTCLR sfr,imm#,short-ladel
 특수기능레지스터를 비트단위로 테스트하고 조건분기한다. 내장 하드웨어
의 상태 체크에 유효하다.

▶TSKSW reg16
 멀티태스크제어를 할경우,  레지스터 뱅크를  절환하는 것으로, 태스크의 
CONTEXT를 절환한다. 절환할 때,  그 시점의 어드레스 플래그를 절환 전의 
레지스터 플래그에 대피시킨다.

▶BRKCS reg16
 레지스터뱅크를 절환하는  것에서, 고속으로  SUBROUTINE CALL,  SOFTWARE 

FLAG를 실행한다. 절환할 때, 앞의 루틴은 어드레스 플래그를,  절환 후의 
레지스터뱅크 내로 저장한다.

▶MOVSPA
 레지스터뱅크 절환으로 인한 인터럽트처리의 앞에서 실행하는 것으로, 절
환전의 레지스터  뱅크에서 SS,SP를 COPY한다.  레지스터뱅크 절환에 의한 
인터럽트 처리에 있어서, 레지스터뱅크 절환의 전후로 STACK을 연속시키는 
목적으로 사용된다.

▶MOVSPB reg16
 레지스터뱅크 절환의 앞에 실행되는  것으로, 그 시점의 SS,SP을 절환 후
의 레지스터뱅크로 COPY한다.  레지스터뱅크 절환의 전후로 스택을 연속시
키는 목적으로 사용된다.

▶V25+ (uPD70325)
 V25에 대해서 대부분이  컴퍼터블의 1칩 마이콤으로서 V25+가 일본전기에 
생산되었다. "대부분"이라는 말과  같이, 단자배열, 특성은 같지만, DMA기
능등 주변기능등의 일부가 V25와 다르기 때문에, 소프트웨어적으로 완전한 
컴퍼터블은 아니다. 비교일람을 표7-9에 나타낸다.
 DMA을 빠르게  한것 외에, 시리얼과  인터럽트 관계의 플래그를 추가하고 
있기 때문에, 보다 사용하기 쉽게 되어있다.



#122   디지탈   (k2dig   )
V25 관련 자료 SP.24 #8-1                     03/05 16:59   264 line

제8장  계측 제어용도에서도 사용하기 편리한
         펄스제어용 LSI HD63140

 HD63140(UPP)은 종래의 타이머/카운타용 LSI보다도 성능이 좋고, CPU에도 
부하가 걸리지 않도록 하는 배려를 하고 있다.

 +----------------------------------------+
 | UPP(Universal Pulse Processor) 의 개요 |
 +----------------------------------------+
 프린터와 사진기등의  OA기기, 혹은 산업용  로보트에서 각종 민생기기에 
이르기까지, 모타 이용의 메카니컬 제어의 분야에서는, 마이콤의 성능향상
으로 인한 디지탈 제어화가 급속도로 추진되고 있다.
 종래 펄스의 계수와  주기측정, 혹은 반복해서 펄스를 발생시키고 펄스의 
듀티제어등의   펄스입출력처리는,  6840(프로그래머블   타이머  모듈)과 
8253/54(프로그래머블 인터벌 타이머)등의 마이콤 주변 LSI가 많이 이용되
었다. 그러나 제어사양의  복잡화와 고속화는, CPU의 소프트웨어의 부담을 
증대 시키고, TTL LOGIC과 GATE ARRAY로서의 전용회로를 사용하게 되었다.
 여기서 설명하는  HD63140(히다찌제작)은, 펄스 입출력처리부에 사용자의 
프로그래머블한 프로세서의  개념을 도입,  하드웨어에 있는 소프트웨어의 
부담의 경감을 도모하고 있다. HD63140의 특징을 설명한다.

⑴ 사용자가 각종펄스  입출력기능을 임의로 설정가능하고, 동일의 하드웨
어에서 다른 제어사양을 실현할수 잇다.
⑵ 처리를 잘 조합시킴으로써, 복잡한 펄스 제어를 행할 수 있다.
⑶ 주변 로직회로의 원칩화가 가능하다

 이 LSI는 펄스  입출력처리기능에 더해서, 마이콤 시스템에서는 없어서는 
안될 RAM(1K Byte),메카니컬 제어에서 필요한 A-D CONVERTOR, 시스템 전체
의 신뢰성을  향상 시켜주는 워치도그 타이머을  내장하고, 시스템 전체의 
소형화를 도모할 수 있다. 때문에, 3장, 4장에서 설명한 것과 같은 모터의 
제어, 엔코더의 펄스계측이라는 것은 최적의 응용인 것이다.

 +-------------------+
 | 입출력단자의 설명 |
 +-------------------+
 HD63140의 패키지는, 그림 8-1에 있는것과 같이 두종류이다.

●입출력단자

▶Vcc,Vss
  전원으로, 복수로 있는 Vss는 전부 GND로 묶는다.

▶AVcc,AVss
 AVcc는 아날로그 전원으로, AVss는 Vss와 공통으로 GND에 접속한다.

▶XTAL,EXTAL
 수정진동자를 접속한다. 16MHz  수정의 경우에, 내부는 최대의 4MHz로 동
작한다. 외부 클록의 경우는, EXTAL단자에서 입력한다.

▶CLK
 내부주파수의 2배의 CLOCK을 출력한다. 4MHz동작에서는 8MHz

▶/RES
 "L"레벨로 리셋 되어진다.

▶/STBY
 "L"레벨로 내부 클록을 정지하고, 스텐바이 상태로 된다.

▶D0 - D7
 8 비트의 데이타 버스

▶A0 - A10
 내장 되어진 레지스타와 RAM의 어드레스를 입력한다.

▶R//W,/DS,/OE/CS
 CPU와의 인터페이스 신호를 입력한다.

▶READY
 CPU에대해, WAIT CYCLE을 삽입하기 위한 신호를 출력한다.

▶/INT0,/INT1
 CPU에대한 인터럽트 신호를 출력한다

▶/WDT0
 워치도그 타이머을 오버 로드 하였을때에, "L"로 출력된다.

▶U0/P10 - U15/P27
 UPP   코아로  처리하는   펄스의   입출력단자.  UPP   CONTECT   ENABLE 

REGISTER1,2( UCER1,2)의 설정으로, CPU 포트로서도 사용가능하다.

▶AN0 - AN9
 A-D CONVERT의 아나로그 입력단자




 +--------------------+
 | 내부의 구성과 동작 |
 +--------------------+
 HD63140의  내부는, 그림  8-2에  있는  것과 같이  UPP  CORE(UPC),  A-D 

CONVERT(A-D), SYSTEM DATA기억용  RAM, 워치도그 타이머(WDT)의 4개의  블
록으로 구성된다.

▶UPP CORE
 전기  펄스의  입출력   처리를  행하는  프로세서이다.  ALU,   FUNCTION 

TABLE(FT), UPP  DATA REGISTER(UDR), CONTROL REGISTER등으로  구성되어있
다. UDR은, 펄스 입출력처리에서 필요한 CAPTURE REGISTER, 출력 처리에서 
필요한 COMPARE REGISTER로서 사용할 수 있을뿐만 아니라, UDR에 기억되어
진 값에 ALU에서  +1또는 -1의 연산처리를 행한  후의 값을 기억하는 것으
로, 카운터와 타이머로서 사용할수 있다.
 FT에는 제어프로그램을 설정한다. 한개의 처리스텝은 그림 8-3에 있는 것
과 같이  7개의 레지스터로 정의한다. 선두의 코맨드 어드레스(cmr)에는, 
표 8-1에 있는 16종류의 전용 코맨드와 코맨드군의 상세모드를 설정한다.
 register assignment register A(RARSA)에서는, 이 코맨드로 카운터와  시
프터로서 사용하는 UDR의  번호를 지정한다. 다음의 RARSB에서는, CAPTURE 
REGISTER와 비교 레지스터로서 사용하는 UDR의 번호를 지정한다.
 I/O ASSIGNMENT REGISTER A (IOARA)에서는, 카운터로 사용하는 외부  클록
의 입력단자 번호등을  지정한다. IOARB에서는, 샘플링 펄스와 트리거펄스
등의 단자 번호등을 지정한다.
 IOARC에서는, 펄스의 출력단자번호를 지정한다. 최후의 IOARD에서는 트리
거 이네이블신호등의 입력단자번호를 지정한다.
 HD63140의 FT는 16 STEP으로, 최대 16개의 코맨드를 설정할수 있다. 또한 
FT에 설정하는 스텝 수를 MAXIMUM FUNCTION NUMBER REGISTER(MFNR)에  지정
한다. 처리정도(펄스폭 분해능)는  MFNR의 값에 따라서 변화하고, 펑션 수 
1에서는 0.5us, 16에서는 5us(16MHz 수정부착 시)로 된다.

▶A-D CONVERT
 변환정도 10  비트의 A-D 콘버트가  10 채널 내장되어있다. 변환데이타를 
셋하는 레지스터가  4개 준비되어있고, 1  채널의 변환을 행하는 단일모드
와, 최대 4채널의 변환을  순서적으로 행하는 SCAN MODE를 사용할수 있다. 
단일 모드에서의 변환시간은 42us이다.
 또한 분해능 8 비트로 사용할 경우를 고려해서, 상위 8 비트의 변환 데이
타에, 하위 2비트를, 하위 바이트의 상위 2비트로 셋트되어진다.

▶RAM
 UPP CORE와는  상호 독립적으로, 1024  바이트의 S-RAM이 내장되어  있다. 

스탠바이모드에서는, 1024 바이트의 저소비전력으로 되는 외에, 전원 전압 
2V까지 기억 데이타를 유지할수 있다.



▶워치도그 타이머
 10비트의 PRE SCALER와,  8 비트의 카운타로 구성되어있다. 일반적으로는  
 
OVERFLOW하지 않도록  CPU에서 정기적으로  RESET하지만, OVERFLOW한 경우
는, /WDT0단자에서 약  8.5us의 "L"신호가 출력되어진다. 이것을 사용하는 
것으로 인해, 무한 루프와 예외조건의 발생등의 이상을 검출할수가 있다.

 +--------+
 | 응용예 |
 +--------+
 HD63140을 VME 버스시스템의 I/O채널용으로 만든 보드와 펄스 제어예를 나
타낸다.
 하드웨어의 설명에 있어서는  모토롤라사의 표기를 이용하였다. 신호명의 
뒤에 '*'는 부논리를 나타낸다.

▶보드의 사양
 이번에 제작한 보드의 사양을 표8-2에 나타내지만, UPP에 내장하는 RAM은 
억세스를 금지하고, 펄스  프로세서와 A-D CONVERT의 기능을 I/O 채널위에
서 실현하고 있다.
 이 보드가 사용하는 어드레스 영역은 112바이트를 사용하기 때문에, A0 - 
A11의 I/O어드레스를 풀 디코드하고, 128 바이트 단위로, 희망하는 어드레
스로 이동시킨다.( 그림 8-4)
 VME의 I/O채널에 관해서는 ,  상세한 설명을 할수 없기 때문에, 참고문헌 
⑵,⑶을 보면된다.
 I/O채널은, STB*와  XACK*의 비동기 HANDSHAKING방식이고, 하드웨어의 설
계에서는, 이 타이밍설계가 포인트가 된다.
 그림 8-5의 블록 다이어그램과 사진 8-1에 타이밍도를 나타낸다. I/O채널 
측에서 보면  STB*의 ASSERT를  받고, 어드레스  데코더와의 논리합으로서 
/CS을 ASSERT한다.  UPP는 /CS의 ASSERT을  받고,  READY을 니게이트하고, 
/DS가 ASSERT되어진뒤, 내부처리시간(최대3us)뒤에 READY을 ASSERT한다.
 다음에  보드측에서는, /DS,/CS의  니게이트, XACK*의  ASSERT을  행하고, 

STB*, XACK*의 니게이트와 연속해서, I/O 채널의 핸드세이크를 완성한다.
 이 회로에서는  사이클로 READY를 니게이트할  필요가있고, <<<ASSERT의 
접속하는 내장  RAM의 불가능하기  때문에,>>> UPP의  어드레스 A7- A10을 
"L"로 고정하고 있다.

▶소프트웨어의 설계
 펄스제어를  위한  UPP의   프로그래밍  모델을  그림  8-6에   나타낸다. 

FUNCTION TABLE(FT)에는,  최대 16종의 펄스제어용  코맨드을 기술할수 있
고, 24개의 데이타 레지스터(UDR)을 필요에 응해서 카운터와 콤퍼레이터로
서 지정가능 하다.
 UPP CORE 부는,  FT의 내용과 UDR의 데이타를 참조하면서, MFNR에의해서, 
표8-3에 결정되어진 펑션수를 순차실행하고, 지정되어진 핀에 대해서 펄스
를 입출력한다.
 또한, MFNR은, 다음의 식에서 나타난 것처럼 펄스폭분해능을 결정한다.

 펄스폭 분해능 = ( MFNR)   0.25us
  그리고, 4MHz동작시

 따라서, 동작하는 펄스수를 작게할수록, 분해능은 좋게 된다.
 입출력 레지스터는 UPP CORE부의 출력치를 제어하고, 인터럽트 제어 레지
스터는 UPP에  입출력되어진 펄스의 엣지  검출에 의한 인터럽트를 제어한
다.
 그림8-7에  UPP CORE부의  프로그램순서를 나타낸다.  입출력 레지스터와 
MFNR의 설정후, UPP를 정지시키고, FT, UDR을 설정 한다.
 UPP의 실행전에 FUNCTION  NUMBER REGISTER의 FNR을 재설정 하고 있는  것
은. FUNCTION NUMBER1 부터 순차 실행시키기 위한 것이다.
 UDR은 2 바이트 구성으로 되어있고, CPU에서의 리드/라이트시에는 상위바
이트, 하위바이트순으로  억세스 할 필요가  있고, CPU가 80계의 경우에는 
역순으로 되기 때문에 주의가 필요하다.

 +--------+
 | 제어예 |
 +--------+
사례1 : 방형파의 발생
 세개의 코맨드를 사용해서, 주기와 펄스폭을 프로그래머블한 방형파의 발
생을 그림 8-8에 나타낸다. FNR=1에는 FFC코맨드를 이용하고, 16us의 펄스
폭을 가진 듀티50%의 펄스를 U0의 핀에 출력한다.
 다음에, FNR=2에서는 INC코맨드를 이용, 앞의 U0의 출력을 카운터용의 클
록으로서 16 카운트하고, U1 핀에 LOW ACTIVE한 펄스를 출력한다.
 다음에, FNR=3에서는 OSC의  코맨드를 이용, 다시한번, U0를 카운터의 클
록으로서 이용,  U1을 트리거신호로서,  네번 카운터로  "L"이 되는   ONE 
SHORT펄스를 U2에 출력한다.
 이 경우,  MFNR에는 4를 설정하기 때문에, 펄스폭분해능은  0.25us   4 = 
1us로 된다.  이 처럼, 복수의 코맨드를  이용해서, 다양한 종류의 펄스를 
얻을수 있다.

사례2 :16CH펄스의 발생예
 UPP의 특징으로 있는 다 채널 펄스를 발생시키기 위한 예를 그림 8-9에 나
타낸다.
 사례1과 같이,  U0에서 기본 클록,  U1에서 트리거펄스를 만들고, U2에서 
U15의 14개 채널 ONE SHORT 펄스를 얻을수 있다. 펑션 테이블은 16종의 펄
스를 정의할수가  있지만, FNR은  1부터 단순히  증가할뿐만 아니라, 도중 
5,10,15는 뛴다. 이러한  세걔의 스텝에서는, UPP CORE부가 내부처리의 사
이클을 실행하기 때문이다.
 또한, 이 예와 같이, 1개의 테이블에는 2개의 UDR을 사용하면, 전 테이블
에는 32개의 UDR이 필요로 된다. 그러나, 실제에는 비교레지스타에 사용된 
UDR은 복수회 사용가능하기 때문에, 최대 16채널의 펄스를 발생 시킬수 있
는 것이다.
 펄스의 사진을 잘 보면, 상승엣지에서 채널수가 증가함에 따라서, 조금씩 
늦어지는 것을 알수 있다.  이것은 UPP CORE부의 연산처리계가 1채널씩 순
서적으로 동작해서 펄스를  발생 시키고 있기때문이다. 이 '지연'은, 당연
하지만 펄스폭분해능(이 경우는 0.25   MFNR = 0.25   20 = 5 us) 의 범위
에 들어가 있다.


사례3 : 펄스폭의 측정
 UPP는 펄스의 발생 뿐만  아니라, UDR을 CAPTURE REGISTER로 지정하는 것
으로, 주기와 펄스폭의 측정도 가능하다.
 그림 8-10에는, GTS  코멘드를 사용해서 'H'레벨의 펄스폭을 측정한 사례
를 나타낸다. 외부에서  입력되어진 피측정용펄스, U1이 'H'레벨의 기간에 
입력되어진 클록 펄스 U0의  상승 엣지의 수를 카운트하고, U1의 하강엣지
에서 카운트값이 캡쳐 레지스터로 들어간다.
 CPU에 대해서는, U1의 하강  또는, 상승 엣지로 인터럽트를 걸고, 캡쳐레
지스터를 읽고서, 펄스폭을 알아 낼수가 있다.
 이 경우에는, U1의 하강엣지로 인터럽트를 발생시키기 때문에, 캡쳐 레지
스터의 데이타  셋트와 인터럽트가 충돌하게  된다. 그러나, 하강엣지 뒤, 
펄스폭분해능으로 설정 되어진 시간뒤에 인터럽트 처리루틴의 가운데에서, 
캡쳐레지스터로 설정한 UDR의 값을 읽으면, 바른 값을 얻어 낼수가 있다.


사례 4 : 펄스의 시프트
 시프트되어진 펄스를  입출력 하는 기능의  예로서, SPO 코맨드를 사용한 
예를 그림 8-11에 나타낸다.
 우선, 이 코맨드는 지정되어진 UDR의 값(여기서는 UDR7에 $C0C0가 들어있
다)을 셋트신호에의해서 시프터(UDR6을  지정)에 로드한다.  그리고, 클록
신호가 들어가는 것으로 1  비트씻, 왼쪽 혹은 오른쪽으로 시프트를 하고, 
동시에 시프터의 값을 포트로 출력한다.
 시프트의 방향은,  CMR레지스터내의 하위  비트로 설정되어진 S0,S1,S2의 
값으로 결정되고, 그림  처럼 S0=S1=S2='1'로 하면, IOARD로 지정되어진 S
핀( 여기서는 DIR핀으로 한다)의 레벨에 의해서 방향이 바뀐다. 'H'레벨에
서는 왼쪽으로 로테이트, 'L'에서는 오른쪽으로 로테이트하게 된다.
 그림에서는 시프터의 값을  U0보다 U7에서 출력하고, 시프트의 도중에 시
프트의 방향을 변환한 경우를  나타낸다. 클록의 진행에 따라 포트의 출력
이 시프트되어지는 것을 알수 있다.




#123   디지탈   (k2dig   )
V25 관련 자료 SP.24 #9-1                     03/05 17:00   78 line

제9장
제어시스템의 실례 - 마이크로마우스

 이상으로 메카트로에 C언어를 사용하는 잇점을 알았다고 생각 된다.
 여기서는, C언어를 사용한  조립컴퓨터를 이용한 메카트로기기의 예로서, 
마이크로마우스(사진 9-1)를 소개한다.
 하드웨어는 3,4장에서 소개한 스테핑모터 구동회로와, 로타리 인코더검출
회로의 응용이다.(그림 9-1)
 소프트웨어는 기본적으로는  3,4장의 내용이지만, 복잡하게 되어있다.(리
스트 9-1  ---- 9-8)
 이 시스템은  보통잡지등에서 볼수 있는 DSP  를 사용한 제어회로와는 달
리, 훨씬 간단한 것이다.그러나, DSP를 이용하지 않으면 안되는 것은 실
지로는 한정된  용도에 지나지 않고, 대부분은  여기서 소개하는 회로로서 
충분하다. 또한,  실제 소프트웨어도 계산을  행하는 부분은 공통인것으로 
입출력을 행하도록 하는것으로  충분하다. 구체적으로 회로에서는 UPP이후
의 모터  드라이버, 소프트웨어에서는 MIO.C가  구동을 시키는 부분인것이
다.
 프로그램의 대부분은 모터를 구동시키는 것보다도, 모터를 어떻게 구동을 
시킬것인가의 계산에  사용되고 있다.  제어용의 프로그램에서는 실제에는 
이 마이크로마으스의 프로그램처럼, 대부분이 계산으로 사용되게 된다.
 실용화되어지는 기계에서는 동일한  것을 반복하는 것이 대부분이기 때문
에, SEQUENCER등의 하드웨어를 이용해서 처리하고 있지만, 마이크로마우스
와 같은 복잡한 동작을 시키는 경우에는 어떻게 해서라도 소프트웨어의 비
중이 크게 된다. 그렇게 되면, 대량의 리스트(프로그램)와의 결합을  하지 
않으면 않된다.
 그 때에,고급언어를 사용할수 있고,  이용, 수정, 이식하기 쉬운 것이 큰 
도움이 되는것이다.

●소프트웨어에 관해서
 소개하는 프로그램은 다음의 6가지로 되어있다.
 소스  프로그램의 총  사이즈는 106K  Byte로,  실행 코드의  사이즈는 약 

32KByte이다.

▶MOUSE.C
 메인 프로그램, 보드상의  로타리 인코더, 딥스위치와 보턴스위치에 의한 
각 루틴을 호출한다.

▶MIO.C
 기본적인 하드웨어 인터페이스 루틴의 경우

▶SEARCH.C
 미로탐색시의 주행루틴

▶SHORT.C
 미로를 탐색하고 최단거리를 발견한후 고속주행을 행하는 루틴

▶SHORT2.C
 미로를 탐색하고,  최단거리를 발견한후 고속주행을  위한 루틴.  좌우의 
턴이 연속한 경우에는 비스듬한 주행을 행한다.

▶ADACH.C
 미로탐색시에 사용하는 미로해석 루틴

▶MOUSE.C
 마우스용의 매크로를  모은 헤더 화일,  하드웨어의 변경과 이식 할때에, 
여기에 기재된 부분을 변경하면 된다.

 이것은 1989년 전일본의 마이크로마우스대회에서 우승한 마우스의 프로그
램이다. 코스 레코드는  12.42초이다. 마이크로마우스 대회의 미로 패턴은 
매회 변경되어진다. 이 때의 최단 경로는 66보 38턴이었다. 거리로 고치면 
38개의 90도 턴이 있는 11.88m의 코스이다.
 마이크로마우스 경기의 포인트는  타이어의 골등에 있는 불확정조건외에, 
보다 빨리 환경에 적응해서  마우스를 제어하는 것에 있다. 그러기 위해서
는 리얼타임성이 요구  되어지지만, 적어도 프로그램의 실행속도를 빠르게 
하기 위해서 프로그램의 전부를 어셈블러로 기술한 마우스도 많이 있다.
 그 가운데에서도  C로 프로그램을 기술한  마우스가 우승을 했다는 것은, 
제어용의 프로그래밍  언어로서 C가 충분히 사용할수  있다는 것이 증명이 
되었다는 것이다.
 프로그램의 대부분은 마우스의 다양한 동작을 제어하기 위한 파라메터 나
열이다.(SHORT2.C)
 그리고, 마이크로마우스대회가 가까워오면  밤을 새서 디버그를 계속하게
되기 때문에, 결국 이해하기 쉬운 프로그램이 아니면 안된다.
 거기서도 어셈블러와는 달리,  뒤에서 부터 보아도 무엇이지를 알수 있도
록 되어있고, 또한, 프로그램 모듈이 다음 에도 이용가능한 것이 고급언어
의 특징인 것이다.




#137   임상희   (zc5u3p  )
iar 8096 C complier 사용예제                 06/13 14:24   258 line

IAR사의 C Complier중 51은 V4를 넘어 V5가 시판되고 있으나, 96은 아직 V3
이다. 51의 경우 버젼 3과 4는 매우 큰 차이를 보이고 있는데, 가장 큰 차
이는 인터럽트 함수의 추가이다.  컨트롤러의 프로그램을 짜다보면 인터럽
트의 사용이 필요한데 버젼 4부터 인터럽트 함수가 추가되어 굳이 어셈블러
로 인터럽트 벡터지정을 하지 않아도 컴파일러와 링커가 자동으로 조정하여
준다.  그리고 컴파일러의 효율도 상당히 좋아서 Tiny Model의 경우 어셈으
로 짠 프로그램에 비해 실행속도면에서 그리 떨어지지않는다.  때문에 현재
우리 연구소에서는 51로 제어기를 만드는 경우 어셈을 전혀 사용치 않고 C
만으로 프로그램 하고 있다.
  그러나 96의 경우 아직 버젼 3인 관계로 인터럽트 함수가 없어 어셈을 사
용하여야만한다.  어셈이 꼭 필요한 부분은 2000H부터 시작되는 인터럽트 
벡터에 인터럽트 시작부분의 어드레스를 넣는 과정과, 실제 인터럽트 루틴
으로 나눌 수 있다.  그런데 2000번지루틴은 CSTARTUP이라는 이름으로 라이
브러리에 포함되어 있다.  따라서 인터럽트 벡더와 인터럽트 루틴을 같이 
CSTARTUP에 포함하게 되면 인터럽트 루틴이 바뀔때마다 라이브러리를 바꾸
어야 하는 불편이 따르게 된다.  그래서 나는 CSTARTUP루틴에는 꼭 필요한 
최소한의 기능만을 넣어서 라이브러리에 넣고, 여러 프로그램에서 같이 사
용할 수 있도록 구성하였다. 

mycstart.asm
===========================================

    NAME    CSTARTUP
    PUBLIC  startup
    PUBLIC  RESETRUN
    EXTERN  ?C_EXIT
    EXTERN  INT_T_OVER_S
    EXTERN  INT_A2D_S
    EXTERN  INT_HSI_S
    EXTERN  INT_HSO_S
    EXTERN  INT_HSI0_S
    EXTERN  INT_SOFT_T_S
    EXTERN  INT_COM_S
    EXTERN  INT_EXTERN_S
    EXTERN  CHIP_CONFIG
    EXTERN  ASM_START

    RSEG    CSTART
startup:                <<==  여기가 2000H번지.
    DCW INT_T_OVER_S    <<==  실제 값은 Link시 결정됨.
    DCW INT_A2D_S
    DCW INT_HSI_S
    DCW INT_HSO_S
    DCW INT_HSI0_S
    DCW INT_SOFT_T_S
    DCW INT_COM_S
    DCW INT_EXTERN_S

    ORG     startup+18H
    DCB CHIP_CONFIG

    ORG startup+80H
RESETRUN:
    LJMP    ASM_START
    ENDMOD  startup

   MODULE  exit
    PUBLIC  exit
    PUBLIC  ?C_EXIT
    EXTERN  RESETRUN

    RSEG    CODE

?C_EXIT:
    LJMP    RESETRUN
exit    EQU ?C_EXIT
    END
=============================================================
이제 이 루틴을 다음과 같이하여 라이브러리에 있는 루틴과 바꾸어야 한다.
*** 라이브러리 루틴을 변경하여야 하므로 8096 C Library가 있는곳에서 
        작업하여야 한다.
    
C:\8096>a8096 mycstart.asm mycstart mycstart
C:\8096>xlib
* def-cpu 8096
* rep-mod mycstart cl8096
* exit
============================================================
이제 사용자가 필요한 루틴을 작성한다.
수행을 위하여는 최소한 하나의 어셈과 C 화일을 필요로 한다.
어셈화일에는 CSTARTUP에서 EXTERN으로 선언한 이름이 반드시 PUBLIC으로 
선언되어 있어야 후에 링크가 된다.

test_asm.asm
===========================================
    NAME    INITIAL_AND_POWER
; 여기서는 모든 프로그램에 꼭 있어야 할 부분임...
$reg8096.INC
    PUBLIC  CHIP_CONFIG
    PUBLIC  ASM_START
    PUBLICINT_T_OVER_S
    PUBLIC  INT_A2D_S
    PUBLIC  INT_HSI_S
    PUBLIC  INT_HSO_S
    PUBLIC  INT_HSI0_S
    PUBLIC  INT_SOFT_T_S
    PUBLIC  INT_COM_S
    PUBLIC  INT_EXTERN_S

    EXTERN  main
    EXTERN  ?C_EXIT

CHIP_CONFIG EQU   0FDH ;11111101B <<= 요값은 하드웨어에 맞게 조정할것

    RSEG    CODE   ; 
INT_T_OVER_S:   ;TIMER OVER FLOW INTERRUPT SERVICE (INT_T_OVER_S)
INT_A2D_S:      ;A/D CONVERT COMPLITE INTERRUPT SERVICE (INT_A2D_S)
INT_HSI_S:      ;HSI DATA AVAILABLE INTERRUPT SERVICE (INT_HSI_S)
INT_HSO_S:      ;HSO EVENT INTERRUPT SERVICE (INT_HSO_S)
INT_HSI0_S:     ;HSI BIT 0 INTERRUPT SERVICE (INT_HSI0_S)
INT_EXTERN_S:   ;EXTERNAL INTERRPUT SERVICE (INT_EXTERN_S)
        RET
            ; 여기까지 인터럽트루틴은 안쓰는 경우.
            ; 아래것은 어셈루틴으로 쓰는 경우.
INT_SOFT_T_S:
    PUSHF
            ; 여기다 필요한 루틴을 집어넣음.
    POPF
    RET
            ; ** C로 인터럽트 루틴을 짤 경우...
INT_COM_S:      ;SERIAL I/O INTERRUPT SERVICE (INT_CON_S)
    PUSHF
    PUSH    R0
    PUSH    R2
    PUSH    R4
    PUSH    R6
    PUSH    R8
    EXTERN  C_INT_ROUTINE
    LCALL   C_INT_ROUTINE
    POP     R8
    POP     R6
    POP     R4
    POP     R2
    POP     R0
    POPF
    RET
            ; 여기서부터 RESET시 시작하는 부분.
ASM_START:
    LD      SP,#100H  ; <<== 값은 필요에 따라 변경하여야 함.
                      ; 가능한한 RAM의 가장 뒤번지인것이 바람직함.
                      
    EXTERN  ?SEG_INIT_L00   ; C 변수 초기화 라이브러리의 호출.
    LCALL   ?SEG_INIT_L00   ; 초기화가 필요 없을땐 호출 안해도 됨.

    LCALL   main            ; C의 메인루틴 호출
    LJMP    ASM_START       ; 이경우는 C루틴이 끝나면 다시 처음부터 수
                            ; 행함.  필요에 따라 변경할것.
    END
=====================================================================
TEST.C96
====================================================================
#include <io8096.h>
#include <math.h>

/*  내부램의 절대번지를 C에서 변수로 쓸때는 다음과 같이 지정함 
    ** 내부램의 23H번지까지는 C Complier가 사용하므로 유저사용 불가.
*/
#define BASE_REG 0x24
#define reg_x  (*(unsigned int  *) (BASE_REG))   
#define reg_y  (*(unsigned int  *) (BASE_REG+2))

int x,y,z;
double d1,d2,d3;
float f1,f2,f3;
long int l1,l2,l3;

double fcross(int i, int j)
{  double l;
   l = i*j;
   return(l);
}
long int lcross(int i, int j)
{  long int l;
   l = i*j;
   return(l);
}

void main(void)
{
   x = sqrt(y);             
   x = sqrt(fcross(y,z));
   x = sqrt(lcross(y,z));
   f1 = sin(f2);
}
=================================================
필요한 테스트 프로그램은 각자 만들어 보기 바라며 실수의 계산이나 삼각
함수의 계산이 모두 가능하다.  사용가능한 함수는 math.h등의 각종 헤더화
일을 보면 알 수 있는데 SIN, COS등은 물론이고 ASIN, ACOS등의 함수도 준
비되어있다.
이제 컴파일과 링크를 할 차례이다.
일단 어셈화일을 먼저 어셈블 한다.

C:\WORK>A8096 TEST_ASM.ASM TEST_ASM TEST_ASM

아무래도 C 컴파일과 링크 과정은 자주할 것이므로 다음과 같이 BAT 화일을
 하나 만들어 놓는것이 편하리라 본다.
===================================================================
C96.bat
====================================================================
icc8096 %1.c96 -z30,60 -l %1 -q -P -r0 -S -x -a %1.asm
if errorlevel=1 goto end
xlink %1 TEST_ASM -f lnk8096 -o %1 -l %1.map -x
hexbin %1.a15 %1.bin i
re %1.bin 2 240
:end
===================================================================
-z30,60 : CPU 내부램의 30H 번지부터 60바이트를 컴파일러가 사용하도록 
        함. 이렇게 하면 함수내부의 지역 변수가 내부램으로 할당되어
        수행 속도가 빨라짐.
-a %1.asm : 컴파일 된 어셈 리스트를 생성함. 필요없음 지워도 됨.
            -q 옵션을 붙이면 리스트 화일에 어셈 코드가 같이 나옴.
    컴파일러의 효율이 그리 좋은편이 못되므로 일단 어셈화일을 생성하고
    속도가 요구되는 부분(인터럽트 루틴등)을 수정해서 다시 어셈블하는것
    도 좋을것이라 생각됨.  물론 실력이 붙어야 할 수 있겠지만...
기타 컴파일 옵션은 icc8096만 치면 화면에 자세히 설명이 나옴.    
xlink에서 "-f lnk8096"은 링크 컴멘드 화일을 지정하는 것으로 링크시에 
필요한 옵션사항들을 나열한 것임.  
위의 bat화일은 롬 애물단지를 사용한 경우로서 마지막의 re는 롬 애물 
기동명령임.  
==============================================================
LNK8096.XCL
=============================================================
-c8096
-Z(CODE)CSTART,CODE,RCODE,CDATA,ZVECT,CONST,CSTR,CCSTR=2000  
-! 롬의 시작번지는 2000H -!
-Z(DATA)DATA,IDATA,UDATA,ECSTR,WCSTR,TEMP,CSTACK=8000
-! 이경우 램의 시작번지는 8000H 하드웨어에 맞도록 조정하여야 함 -!
-e_medium_read=_formatted_read
cl8096
-!  -e_small_write=_formatted_write    
    위의 줄을 쓸경우 printf에서 실수는 사용하지 못함. 
    대신 메모리가 절약됨(롬/램 모두)
-!
=============================================================
xcl화일에서 -! 는 C에서의 /*, */ 와 같은 기능을 가짐.
bat와 xcl, C Source 가 준비되었으면 bat화일로 컴파일/링크/실행
을 시킴.

C:\WORK\>C96 TEST

==== 사족 ====
 
- A8096.EXE와 ICC8096.EXE가 있는 DIRECTORY는 PATH로 지정하는것이 편하다.
- 다음명령을 AUTOEXEC.BAT에 넣어두면 라이브러리와 INCLUDE화일이 작업 
   디렉토리에 없어도 된다.

    set C_INCLUDE=c:\iar\inc\
    set XLINK_DFLTDIR=c:\iar\lib\
                
            ** C:\IAR\INC\   <<== *.H 가 있는 디렉토리
            ** C:\IAR\LIB\   <<== *.R* (LIBRARY)가 있는 디렉토리

- IAR에서나온 8096 C COMPLIER MANUAL은 매우 부실하므로 굳이 구하려 
 들지말고 차라리 8051 COMPLIER MANUAL을 구해 보는것이 훨씬 자세하다.
 
 
 === 정원아빠 ===
 
