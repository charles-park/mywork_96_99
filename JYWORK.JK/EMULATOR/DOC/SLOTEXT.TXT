******************************************************************************

       This is a text type specification of the symbol table that can
       be read in by iSYSTEM's emulators.

       You can check a SIT file format with the SITTEST.EXE utility that
       reads in the SIT file and writes the recognized symbols to 'SIT.SYM'
       file.

******************************************************************************

There are following rules:

 - the file must carry a '.SIT' extension.

 - first line must contain following string to allow type recognition:
       260691SLO

 - MODULE defines a program module generated from a source file or a
   precompiled object module or library.
   <module name> is a mandatory field, up to 8 characters
   {module source} is an optional field specifying the path to the source
     file from which the module was generated.

 - LINE defines a high level or assembler statement association between
   a line in source code of the preceeding MODULE definition and a target
   location.
   <address> is the address of the code associated with the line symbol
   <line number> defines the position of the line in the source file
   {column} is optional, defining the column in which the line starts
   {last line} is optional, defining the last line of the line symbol
   {last column} is optional, defining the last column of the line symbol

 - GLOBAL defines a global variable, defined in the preceeding MODULE
   definition. If there was no preceeding MODULE definition it is associated
   to a predefined module with blank name.
   <variable name> is the name of the variable
   <address> is the address of the variable
   {type} is optional, defining the type of variable

 - LABEL defines a code label (usually generated by assembler), defined
   in the preceeding MODULE definition. If there was no preceeding MODULE
   definition it is associated to a predefined module with blank name.
   <label name> is the name of the label
   <address> is the address of the label

 - CONSTANT defines an association between a name and a value, typicaly
   defined by an EQU statement or a C const definition.
   <constant name> is the name of the constant
   <value> is a decimal (if not explicitly specified hex with the 0x prefix)
     value of the constant

 - FUNCTION defines a high level procedure or a nested block. A function
   will have a non-blank name and is assumed to be defined in the preceeding
   MODULE definition. A nested block caries a blank name. Its scope
   definition does not necessary reffer to the preceeding FUNCTION
   declaration, but is calculated from its address. Blocks that can not be
   fitted in a function are not allowed.
   <function name> is the name of the function. If blank, than this is a
     block definition
   <address> is the first address of the function/block.
   <exit address 1>,..,<exit address n> are exit addresses from the
     function/block. At least one exit (highermost) must be specified.

 - LOCAL defines a local variable. It is assumed to be defined in the
   preceeding FUNCTION definition (true function or a block)
   <variable name> is the name of the variable
   <address> is the address of the variable
   {type} is optional, defining the type of variable

 - FORMULA defines address meaning. A formula must be defined prior to
   its usage in any address definition.
   <formula number> is the index number of the formula by which it will
     be referred to in address definitions (1-255)
   <formula definition> is a string, defining the way a physical address is
     calculated. See CPU appendix for information on defined formulas.

 - any other line type is ignored.

MODULE   <module name>,{module source}
LINE     <address>,<line number>,{column,{last line, {last column}}}
GLOBAL   <variable name>,<address>,{type}
LABEL    <label name>,<address>
CONSTANT <constant name>,<value>
FUNCTION <function name>,<address>,<exit address 1>,..,<exit address n>
LOCAL    <variable name>,<address>,<type>
FORMULA  <formula number>,<formula definition>

<address> of an object is a decimal value, or hexadecimal if prefixed with
          a '0x' prefix.
   10     address 10 (0Ah)
   0x10   address 16 (10h)

Optionally the address value can pe preceeded by a number and a colon sign,
thus overriding the default physical linear address meaning.
   1:10   value 10 aplied on formula 1. If formula 1 is '(SP+ADDRESS)' then
          the 10 specifies a 10 byte offset from the SP register.

<type> of the variable can be one of the bellow types
   void  void type
   bit   is a single bit
   s8    is a    signed  8 bit entity (char)
   u8    is an unsigned  8 bit entity (unsigned char)
   s16   is a    signed 16 bit entity (int)
   u16   is an unsigned 16 bit entity (unsigned int)
   s32   is a    signed 32 bit entity (long)
   u32   is an unsigned 32 bit entity (unsigned long)
   f32   if a  32 bit float number    (float)
   f64   if a  64 bit float number    (double)
   f80   if an 80 bit float number    (long double)

A type can be prefixed by a 'p' thus specifying a pointer to the type:
   ps8   is a pointer to s8 type (*char), etc.
Size of a pointer can be specified by a decimal digit following the 'p'.
If no size is specified a value 2 is assumed.
   p2s8  is a 2 byte pointer to s8 type (*char),
Memory area to which the pointer is pointing can be specified by a decimal
number following the 'p<size>' where <size> is a mandatory single digit
pointer size specifier. The Number that follows specifies the index of a
linear formula that points to the memory area. If no number is specified
default formula (ADDRESS) is assumed (CODE on 8031).
   p24s8 is a 2 byte pointer to s8 type (*char), the object of the type s8
         is specified with formula 4. (If the 4-th formula is
         (XDATA)(ADDRESS), then this is a pointer that points to XDATA area).

A type can be prefixed by an 'a' followed by a number, thus specifying
an array of the type:
   a40s8   is an array of 40 s8 elements (char[40])
   a10pu16 is an array of 10 pointers to u16 elements (unsigned int *[40])


Examples:

An SIT file can contain only simple user extensions to the symbol table,
thus defining aditional symbols:

260691SLO
GLOBAL HeapOrigin,0x4000
LABEL  start,0

The above file defines an untyped global symbol 'HeapOrigin', located on
address 4000h and program label 'start' on address 0.

If you write your own translator from your linker output or listing file
the SIT file might look something like this:

260691SLO
FORMULA    1,(IX+ADDRESS)
MODULE     STARTUP,C:\LUKNA\STARTUP.ASM
LABEL      start,0
GLOBAL     StackTop,0xFFFF
CONSTANT   StackSize,0x1000
MODULE     MAIN,C:\LUKNA\MAIN.C
LINE       0x1000,10
LINE       0x1008,12
LINE       0x1010,13
LINE       0x103C,17
LINE       0x106A,18
LINE       0x1070,20
GLOBAL     c,0x4000,s8
FUNCTION   main,0x1000,0x1080
LOCAL      i,1:-2,s16
FUNCTION   ,0x1010,0x106A
LOCAL      i,1:-6,f32

If you decide to write your own translator, this is what you should best do:
  - write the 260691SLO header
  - write all required formulas
  - write global variables and labels that are not defined in any of modules
  - write module by module with its lines, globals, labels and functions

CPU appendix
------------

Depending on the CPU different addressing modes to access variables can be
used. The below list lists available formulas for different CPU families:


Z80 family
----------
(ADDRESS)              default linear addressing mode
(<register>+ADDRESS)   offset from a CPU register. '<register>' is any CPU
                       register. Example: (IX+ADDRESS)
<register>             variable stored in a CPU register. Example: HL

The first two formulas can be preceeded by a memory area specifier, thus
overriding the default linear logical CPU addressing:

(PHYSICAL)(ADDRESS)    physical address (after MMU translation)
(IO)(ADDRESS)          logical IO address. Defines an IO address.


8031 family
-----------
(ADDRESS)              default linear addressing mode
<register>             variable stored in a CPU register. Example: R0
(<register>+ADDRESS)   offset from a CPU register. '<register>' is any CPU
                       register. Example: (SP+ADDRESS)
((<variable>)+ADDRESS) offset from a variable. '<variable>' is any simple
                       type variable. Example: ((?C_XBP)+ADDRESS).

All above formulas must be preceeded by a memory area specifier, thus
defining the CPU memory area. If none is specified CODE is assumed.

(CODE)(ADDRESS)        linear addressing in the CODE area
(DATA)(ADDRESS)        linear addressing in the DATA area
(IDATA)(ADDRESS)       linear addressing in the IDATA area
(XDATA)(ADDRESS)       linear addressing in the XDATA area

Note: XDATA and CODE addresses can be 24 bits wide, where the low 16 bits
define the logical value, and the high 8 bits the bank number.


6800 family
-----------
(ADDRESS)              default linear addressing mode
<register>             variable stored in a CPU register. Example: D
(<register>+ADDRESS)   offset from a CPU register. '<register>' is any CPU
                       register. Example: (SP+ADDRESS)
((<register>)+N+ADDRESS) final address is calculated by taking contents of
                       the <register>, reading memory from this value, adding
                       N (any integral value) and adding address of the object

The first formula can be preceeded by a memory area specifier, thus
overriding the default linear logical CPU addressing:

(PHYSICAL)(ADDRESS)    banked address. The low 16 bits are the logical
                       address, the high 8 bits are the bank number.


80166 family
------------
(ADDRESS)              default linear addressing mode
(BDATA)(ADDRESS)       linear addressing mode of bit addressable objects
(<register>+ADDRESS)   offset from a CPU register. '<register>' is any Rn
                       register. Example: (R0+ADDRESS)
<register>             variable stored in a CPU register. Example: R0
<register>.ADDRESS     one of 16 bits of a Rn register. Example:   R0.ADDRESS

